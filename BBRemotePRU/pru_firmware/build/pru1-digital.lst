PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    1

       1; Raul Emlio Romero
       2;
       3; cd /sys/class/remoteproc/remoteproc2
       4; echo 'am335x-pru1-digital-fw' > firmware
       5; echo 'start' > state
       6; echo 'stop' > state
       7; cd /sys/kernel/debug/remoteproc/remoteproc2
       8; sudo cat regs
       9;
      10; PRU definitions
      11
      12; pru1Control
      13  .asg 0x22000, PRU0_CTRL
      14  .asg 0x24000, PRU1_CTRL                               ; page 19
      15  .asg 0x28, CTPPR0                                     ; page 75
      16
      17; memory
      18  .asg 0x00000000, RAM0_ADDR                            ; local addr ram0. In linux space addr is 0x4a
      19  .asg 0x00002000, RAM1_ADDR                            ; local addr ram1. In linux space addr is 0x4a
      20  .asg 0x00010000, SHARED_ADDR                          ; local addr shared. In linux space addr is 0x
      21
      22  .asg 0x00, SHD_GPIO_INPUT_MODE0_FLAG                  ; shared[0] gpio_input mode 0 flag function
      23  .asg 0x04, SHD_GPIO_INPUT_MODE0_DATA                  ; shared[1] gpio_input mode 0 data
      24  .asg 0x08, SHD_GPIO_INPUT_MODE1_FLAG                  ; shared[2] gpio_input mode 1 flag function
      25  .asg 0x0C, SHD_GPIO_INPUT_MODE1_DATA                  ; shared[3] gpio_input mode 1 data
      26  .asg 0x10, SHD_GPIO_INPUT_MODE2_FLAG                  ; shared[4] gpio_input mode 2 flag function
      27  .asg 0x14, SHD_GPIO_INPUT_MODE2_DATA                  ; shared[5] gpio_input mode 2 data
      28
      29  .asg 0x18, SHD_GPIO_OUTPUT_MODE0_FLAG                 ; shared[6] gpio_output mode 0 flag function
      30  .asg 0x1C, SHD_GPIO_OUTPUT_MODE0_DATA                 ; shared[7] gpio_output mode 0 data
      31  .asg 0x20, SHD_GPIO_OUTPUT_MODE1_FLAG                 ; shared[8] gpio_output mode 1 flag function
      32  .asg 0x24, SHD_GPIO_OUTPUT_MODE1_DATA                 ; shared[9] gpio_output mode 1 data
      33
      34  .asg 0x28, SHD_MOTOR_MODE0_FLAG                       ; shared[10] motor mode 0 flag function
      35  .asg 0x2C, SHD_MOTOR_MODE0_DATA                       ; shared[11] motor mode 0 data
      36  .asg 0x30, SHD_MOTOR_MODE1_FLAG                       ; shared[12] motor mode 1 flag function
      37  .asg 0x34, SHD_MOTOR_MODE1_DATA                       ; shared[13] motor mode 1 data
      38  .asg 0x38, SHD_MOTOR_MODE2_FLAG                       ; shared[14] motor mode 2 flag function
      39  .asg 0x3C, SHD_MOTOR_MODE2_DATA                       ; shared[15] motor mode 2 data
      40  .asg 0x40, SHD_MOTOR_MODE3_FLAG                       ; shared[16] motor mode 3 flag function
      41  .asg 0x44, SHD_MOTOR_MODE3_DATA                       ; shared[17] motor mode 3 data
      42
      43  .asg 0x48, SHD_MOTOR_STEP_PERIOD_A                    ; shared[18] motor_A STEP_PERIOD_A
      44  .asg 0x4C, SHD_MOTOR_STEP_PERIOD_B                    ; shared[19] motor_B STEP_PERIOD_B
      45  .asg 0x50, SHD_MOTOR_STEP_PERIOD_C                    ; shared[20] motor_C STEP_PERIOD_C
      46  .asg 0x54, SHD_MOTOR_STEP_PERIOD_D                    ; shared[21] motor_D STEP_PERIOD_D
      47
      48  .asg 0x0F, SHARED_MEM_SIZE                            ; 15 en decimal
      49  .asg 0x04, OFFSET_MEM                                 ;
      50
      51; gpio bank
      52  .asg 0x44e07000, GPIO0                                ; GPIO Bank 0, See the AM335x TRM
      53  .asg 0x481ac000, GPIO2                                ; GPIO Bank 2
      54
      55  .asg 0x190, GPIO_CLRDATAOUT                           ; for clearing the GPIO registers
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    2

      56  .asg 0x194, GPIO_SETDATAOUT                           ; for setting the GPIO registers
      57  .asg 0x13C, GPIO_DATAOUT                              ; for read-write the GPIO registers
      58  .asg 0x138, GPIO_DATAIN                               ; for reading the GPIO registers
      59  .asg 0x38,  GPIO_IRQSTATUS_SET_1                      ; habilita las interrupciones por set
      60  .asg 0x148, GPIO_RISINGDETECT                         ; habilita las interrupciones por flanco asc
      61  .asg 0x30,  GPIO_IRQSTATUS_1                          ; get-set irq
      62  .asg 0x150, GPIO_DEBOUNCENABLE                        ; antirebote enable register
      63  .asg 0x54,  GPIO_DEBOUNCINGTIME                       ; configure debouncingtime register
      64  .asg 0xD,  DEBOUNCETIME                               ; Debouncing Value = (DEBOUNCETIME + 1) * 31 m
      65  .asg 0xF00, GPIO0_LEVELDETECT_MASK                    ; bits 8-11 estas entradas estan configuradas 
      66  .asg 0x08800000, GPIO0_RISINGDETECT_MASK              ; bit23 y bit 27
      67  .asg 0x0C, GPIO2_RISINGDETECT_MASK                    ; bit2 y bit3
      68
      69  .asg 0x130, GPIO_CTRL                                 ; enable GPIO port
      70  .asg 0x00,  GPIO_CTRL_ENABLE                          ;
      71  .asg 0x134, GPIO_OE                                   ; set GPIO input - output
      72  .asg 0xFC3C003F, GPIO2_OE_IN_OUT                      ; pines usados como salida bit6 a bit17 y bit2
      73  .asg 0x0CC00F00, GPIO0_OE_IN_OUT                      ; pines usados como entrada bits8-11, bits22-2
      74
      75; gpio_read
      76  ; Pins
      77  .asg 8,  GPIO0_8_GPIO_INPUT_0                         ; P8_35 gpio0[8] -> bit8 input_0  no hace falt
      78  .asg 9,  GPIO0_9_GPIO_INPUT_1                         ; P8_33 gpio0[9] -> bit9 input_1  no hace falt
      79  .asg 10, GPIO0_10_GPIO_INPUT_2                        ; P8_31 gpio0[10]-> bit10 input_2 no hace falt
      80  .asg 11, GPIO0_11_GPIO_INPUT_3                        ; P8_32 gpio0[11]-> bit11 input_3 no hace falt
      81
      82  ; MOTOR_A hardware pins
      83  .asg 22, GPIO0_22_INPUT_MA_DISABLE                    ; P8_19 gpio0[22]-> bit22 input_MA_E set disab
      84  .asg 23, GPIO0_23_INPUT_MA_TOGGLE_DIR                 ; P8_13 gpio0[23]-> bit23 input_MA_D set toogl
      85  ; MOTOR_B hardware pins
      86  .asg 26, GPIO0_26_INPUT_MB_DISABLE                    ; P8_14 gpio0[26]-> bit26 input_MB_E set disab
      87  .asg 27, GPIO0_27_INPUT_MB_TOGGLE_DIR                 ; P8_17 gpio0[27]-> bit27 input_MB_D set toogl
      88
      89  ; TRIGGER RESING DETECT
      90  .asg 2, GPIO2_2_INPUT_GPIO_INPUT_TRIGGER              ; P8_07 gpio2[2]-> bit2 input gpio_input send 
      91  .asg 3, GPIO2_3_INPUT_MOTOR_TRIGGER                   ; P8_08 gpio2[3]-> bit3 input motor send risin
      92
      93; gpio_write
      94  .asg  (1<<22),  GPIO_OUT_BASE                         ;
      95  ; Pins
      96  ; P8_27 gpio2[22]-> bit22 output_0 no hace falta hacer: config-pin P8_27 gpio
      97  ; P8_29 gpio2[23]-> bit23 output_1 no hace falta hacer: config-pin P8_29 gpio
      98  ; P8_28 gpio2[24]-> bit24 output_2 no hace falta hacer: config-pin P8_28 gpio
      99  ; P8_30 gpio2[25]-> bit25 output_3 no hace falta hacer: config-pin P8_30 gpio
     100
     101; motor
     102  ; Enable-Direction
     103  .asg (1<<6), GPIO_MOTOR_ENA_BASE                      ;
     104  .asg (1<<7), GPIO_MOTOR_DIR_BASE                      ;
     105
     106  ; Pins
     107  .asg 6, OUTPUT_MA_E                                   ; P8_45 gpio2[6] -> bit6 output_MA_E no hace f
     108  .asg 7, OUTPUT_MA_D                                   ; P8_46 gpio2[7] -> bit7 output_MA_D config-pi
     109
     110  .asg 8, OUTPUT_MB_E                                   ; P8_43 gpio2[8] -> bit8 output_MB_E config-pi
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    3

     111  .asg 9, OUTPUT_MB_D                                   ; P8_44 gpio2[9] -> bit9 output_MB_D config-pi
     112
     113  .asg 10, OUTPUT_MC_E                                  ; P8_41 gpio2[10]-> bit10 output_MC_E config-p
     114  .asg 11, OUTPUT_MC_D                                  ; P8_42 gpio2[11]-> bit11 output_MC_D config-p
     115
     116  .asg 12, OUTPUT_MD_E                                  ; P8_39 gpio2[12]-> bit12 output_MD_E config-p
     117  .asg 13, OUTPUT_MD_D                                  ; P8_40 gpio2[13]-> bit13 output_MD_D config-p
     118
     119  ; Step period (medio ciclo de la senial)
     120  .asg (1<<14), OUTPUT_MA_S                             ; P8_37 gpio2[14] output_MA_S no hace falta ha
     121  .asg (1<<15), OUTPUT_MB_S                             ; P8_38 gpio2[15] output_MB_S
     122  .asg (1<<16), OUTPUT_MC_S                             ; P8_36 gpio2[16] output_MC_S
     123  .asg (1<<17), OUTPUT_MD_S                             ; P8_34 gpio2[17] output_MD_S
     124
     125; functions flags
     126  .asg 0, GPIO_INPUT_MODE0_FLAG                         ;
     127  .asg 0, GPIO_INPUT_MODE1_FLAG                         ;
     128  .asg 0, GPIO_INPUT_MODE2_FLAG                         ;
     129  .asg 0, GPIO_OUTPUT_MODE0_FLAG                        ;
     130  .asg 0, GPIO_OUTPUT_MODE1_FLAG                        ;
     131  .asg 0, MOTOR_MODE0_FLAG                              ;
     132  .asg 0, MOTOR_MODE1_FLAG                              ;
     133  .asg 0, MOTOR_MODE2_FLAG                              ;
     134  .asg 0, MOTOR_MODE3_FLAG                              ;
     135
     136  .asg 12, GPIO_INPUT_MODE0_DATARDY_FLAG                ;
     137  .asg 12, GPIO_INPUT_MODE1_DATARDY_FLAG                ;
     138  .asg 12, GPIO_INPUT_MODE2_DATARDY_FLAG                ;
     139  .asg 12, GPIO_OUTPUT_MODE0_DATARDY_FLAG               ;
     140  .asg 12, GPIO_OUTPUT_MODE1_DATARDY_FLAG               ;
     141  .asg 12, MOTOR_MODE0_DATARDY_FLAG                     ;
     142  .asg 12, MOTOR_MODE1_DATARDY_FLAG                     ;
     143  .asg 12, MOTOR_MODE2_DATARDY_FLAG                     ;
     144  .asg 12, MOTOR_MODE3_DATARDY_FLAG                     ;
     145
     146  .asg 32, PRU0_R31_VEC_VALID                           ; allows notification of program completion
     147  .asg 3,  PRU_EVTOUT_0                                 ; the event number that is sent back
     148
     149  ; para ver pruout_fs_sample_test en debug hay que cargarlo en el PRU0
     150  ; porque en PRU1  se utilizaron todos los pines
     151  ;.asg r30.t5, pruout_fs_sample_test                   ; debug-> usando PRU usamos esta salida para v
     152
     153  .clink
     154  .global start
     155
     156 00000000                 start:
     157; Registro fijos
     158 00000000 000094240001D4    LDI32 r20, SHARED_ADDR                                ; shared_addr_base
     159  ; r10-> STEP_PERIOD_A
     160  ; r11-> STEP_PERIOD_B
     161  ; r12-> STEP_PERIOD_C
     162  ; r13-> STEP_PERIOD_D
     163  ; r21-r25-> DEBUG
     164
     165 00000008                 SETUP:
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    4

     166;  CLR   r30, pruout_fs_sample_test
     167; borrado de momoria
     168 00000008 0000002EFF8180    ZERO  &r0, 4                                          ; zero put register
     169 0000000c 000081240000C1    LDI32 r1, 0                                           ; offset_mem
     170 00000014 000082240000C2    LDI32 r2, 0                                           ; Count mem
     171 0000001c                 mem_init:
     172 0000001c 000000E0E13480    SBBO  &r0, r20, r1, 4                                 ;
     173 00000020 0000000104E1E1    ADD   r1, r1, 4                                       ; cada posicion de memoria ocupa 4 bytes
     174 00000024 0000000101E2E2    ADD   r2, r2, 1                                       ; count++
     175 00000028 000000670FE2FD    QBGT  mem_init, r2, SHARED_MEM_SIZE                   ; qbgt myLabel, r3, r4. Branch if r4 > r3
     176
     177 0000002c                 gpio_config:
     178;GPIO0
     179 0000002c 7130802444E0C0    LDI32 r0, (GPIO0|GPIO_CTRL)                           ; load GPIO0 control register address
     180 00000034 000081240000C1    LDI32 r1, GPIO_CTRL_ENABLE                            ; load control enable value
     181 0000003c 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; write enable value to GPIO0 control register
     182
     183 00000040 7134802444E0C0    LDI32 r0, (GPIO0|GPIO_OE)                             ; load GPIO0 output enable register address
     184 00000048 0F0081240CC0C1    LDI32 r1, GPIO0_OE_IN_OUT                             ; set GPIO0 as input
     185 00000050 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; write input configuration to GPIO0
     186
     187  ; pines flanco asc
     188 00000054 7148802444E0C0    LDI32 r0, (GPIO0|GPIO_RISINGDETECT)                   ; load addr for GPIO0
     189 0000005c 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     190 00000060 0000001F08E1E1    SET   r1, r1, GPIO0_8_GPIO_INPUT_0                    ;
     191 00000064 0000001F09E1E1    SET   r1, r1, GPIO0_9_GPIO_INPUT_1                    ;
     192 00000068 0000001F0AE1E1    SET   r1, r1, GPIO0_10_GPIO_INPUT_2                   ;
     193 0000006c 0000001F0BE1E1    SET   r1, r1, GPIO0_11_GPIO_INPUT_3                   ;
     194 00000070 0000001F16E1E1    SET   r1, r1, GPIO0_22_INPUT_MA_DISABLE               ;
     195 00000074 0000001F17E1E1    SET   r1, r1, GPIO0_23_INPUT_MA_TOGGLE_DIR            ;
     196 00000078 0000001F1AE1E1    SET   r1, r1, GPIO0_26_INPUT_MB_DISABLE               ;
     197 0000007c 0000001F1BE1E1    SET   r1, r1, GPIO0_27_INPUT_MB_TOGGLE_DIR            ;
     198;  LDI32 r1, GPIO0_RISINGDETECT_MASK                    ; input toggles bit23 y bit27
     199 00000080 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     200
     201  ; enable irq set_1
     202 00000084 7038802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_SET_1)                ; load addr for GPIO0
     203 0000008c 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     204 00000090 0000001F08E1E1    SET   r1, r1, GPIO0_8_GPIO_INPUT_0                    ;
     205 00000094 0000001F09E1E1    SET   r1, r1, GPIO0_9_GPIO_INPUT_1                    ;
     206 00000098 0000001F0AE1E1    SET   r1, r1, GPIO0_10_GPIO_INPUT_2                   ;
     207 0000009c 0000001F0BE1E1    SET   r1, r1, GPIO0_11_GPIO_INPUT_3                   ;
     208 000000a0 0000001F16E1E1    SET   r1, r1, GPIO0_22_INPUT_MA_DISABLE               ;
     209 000000a4 0000001F17E1E1    SET   r1, r1, GPIO0_23_INPUT_MA_TOGGLE_DIR            ;
     210 000000a8 0000001F1AE1E1    SET   r1, r1, GPIO0_26_INPUT_MB_DISABLE               ;
     211 000000ac 0000001F1BE1E1    SET   r1, r1, GPIO0_27_INPUT_MB_TOGGLE_DIR            ;
     212;  LDI32 r1, GPIO0_RISINGDETECT_MASK                    ; input toggles bit23 y bit27
     213 000000b0 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     214
     215  ; configuracion antirebote
     216;  LDI32 r0, (GPIO0|GPIO_DEBOUNCINGTIME)                ; load addr for GPIO0
     217;  LBBO  &r1, r0, 0, 4                                  ; Load the values at r0 into r1.
     218;  LDI32 r1, GPIO_DEBOUNCINGTIME                        ; debouncingtime 0-255
     219;  SBBO  &r1, r0, 0, 4                                  ; Load the values at r0 into r1.
     220
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    5

     221  ; Muy importante primero hay que definir el debouncingtime y luego habilitar el modulo
     222;  LDI32 r0, (GPIO0|GPIO_DEBOUNCENABLE)                 ; load addr for GPIO0
     223;  LBBO  &r1, r0, 0, 4                                  ; Load the values at r0 into r1.
     224;  LDI32 r1, 0x0                                        ;
     225;  LDI32 r1, GPIO0_LEVELDETECT_MASK                     ; input GPIO0 bits 8-11
     226;  SBBO  &r1, r0, 0, 4                                  ; Load the values at r0 into r1.
     227
     228;GPIO2
     229 000000b4 C1308024481AC0    LDI32 r0, (GPIO2|GPIO_CTRL)                           ; load GPIO2 control register address
     230 000000bc 000081240000C1    LDI32 r1, GPIO_CTRL_ENABLE                            ; load control enable value
     231 000000c4 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; write enable value to GPIO2 control register
     232
     233 000000c8 C1348024481AC0    LDI32 r0, (GPIO2|GPIO_OE)                             ; load GPIO2 output enable register address
     234 000000d0 003F8124FC3CC1    LDI32 r1, GPIO2_OE_IN_OUT                             ; set GPIO2 as output ojo aca tambien estamos 
     235 000000d8 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; write output configuration to GPIO2
     236
     237  ; rising detect
     238 000000dc C1488024481AC0    LDI32 r0, (GPIO2|GPIO_RISINGDETECT)                   ; load addr for GPIO2
     239 000000e4 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     240 000000e8 0000001F02E1E1    SET   r1, r1, GPIO2_2_INPUT_GPIO_INPUT_TRIGGER        ;
     241 000000ec 0000001F03E1E1    SET   r1, r1, GPIO2_3_INPUT_MOTOR_TRIGGER             ;
     242;  LDI32 r1, GPIO2_RISINGDETECT_MASK                    ; input bit1
     243 000000f0 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     244
     245  ; enable irq set_1
     246 000000f4 C0388024481AC0    LDI32 r0, (GPIO2|GPIO_IRQSTATUS_SET_1)                ; load addr for GPIO2
     247 000000fc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     248 00000100 0000001F02E1E1    SET   r1, r1, GPIO2_2_INPUT_GPIO_INPUT_TRIGGER        ;
     249 00000104 0000001F03E1E1    SET   r1, r1, GPIO2_3_INPUT_MOTOR_TRIGGER             ;
     250;  LDI32 r1, GPIO2_RISINGDETECT_MASK                    ; input bit1
     251 00000108 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     252
     253 0000010c C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load GPIO2 output
     254 00000114 0000002EFF8181    ZERO  &r1, 4                                          ;
     255 00000118 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; Cargamos todas las salidas en cero
     256
     257 0000011c                 MAIN_LOOP:
     258;  SET   r30, pruout_fs_sample_test
     259 0000011c                 level_gpio_input_mode0:
     260 0000011c 000000F1003480    LBBO  &r0, r20, SHD_GPIO_INPUT_MODE0_FLAG, 4          ;
     261 00000120 000000D100E03C    QBBS  GPIO_INPUT_MODE0, r0, GPIO_INPUT_MODE0_FLAG     ; jump is set bit14
     262 00000124                 level_gpio_input_mode1:
     263 00000124 000000F1083480    LBBO  &r0, r20, SHD_GPIO_INPUT_MODE1_FLAG, 4          ;
     264 00000128 000000D100E047    QBBS  GPIO_INPUT_MODE1, r0, GPIO_INPUT_MODE1_FLAG     ; jump is set bit14
     265 0000012c                 level_gpio_input_mode2:
     266 0000012c 000000F1103480    LBBO  &r0, r20, SHD_GPIO_INPUT_MODE2_FLAG, 4          ;
     267 00000130 000000D100E059    QBBS  GPIO_INPUT_MODE2, r0, GPIO_INPUT_MODE2_FLAG     ; jump is set bit14
     268
     269 00000134                 level_gpio_output_mode0:
     270 00000134 000000F1183480    LBBO  &r0, r20, SHD_GPIO_OUTPUT_MODE0_FLAG, 4         ;
     271 00000138 000000D100E071    QBBS  GPIO_OUTPUT_MODE0, r0, GPIO_OUTPUT_MODE0_FLAG   ; jump is set bit14
     272 0000013c                 level_gpio_output_mode1:
     273 0000013c 000000F1203480    LBBO  &r0, r20, SHD_GPIO_OUTPUT_MODE1_FLAG, 4         ;
     274 00000140 000000D100E07C    QBBS  GPIO_OUTPUT_MODE1, r0, GPIO_OUTPUT_MODE1_FLAG   ; jump is set bit14
     275
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    6

     276 00000144                 level_motor_mode0:
     277 00000144 000000F1283480    LBBO  &r0, r20, SHD_MOTOR_MODE0_FLAG, 4               ;
     278 00000148 000000D100E099    QBBS  MOTOR_MODE0, r0, MOTOR_MODE0_FLAG               ; jump is set bit14
     279 0000014c                 level_motor_mode1:
     280 0000014c 000000F1303480    LBBO  &r0, r20, SHD_MOTOR_MODE1_FLAG, 4               ;
     281 00000150 000000D100E0A4    QBBS  MOTOR_MODE1, r0, MOTOR_MODE1_FLAG               ; jump is set bit14
     282 00000154                 level_motor_mode2:
     283 00000154 000000F1383480    LBBO  &r0, r20, SHD_MOTOR_MODE2_FLAG, 4               ;
     284 00000158 000000D100E0B6    QBBS  MOTOR_MODE2, r0, MOTOR_MODE2_FLAG               ; jump is set bit14
     285 0000015c                 level_motor_mode3:
     286 0000015c 000000F1403480    LBBO  &r0, r20, SHD_MOTOR_MODE3_FLAG, 4               ;
     287 00000160 000000D100E0C6    QBBS  MOTOR_MODE3, r0, MOTOR_MODE3_FLAG               ; jump is set bit14
     288
     289 00000164                 level_motorA_step_time:
     290 00000164 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     291 0000016c 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     292 00000170 000000D106E1F4    QBBS  STEP_PERIOD_A, r1, OUTPUT_MA_E                  ; jump is output_MA_E is set bit6
     293 00000174 000000C906E1FF    QBBC  DISABLE_OUTPUT_MA, r1, OUTPUT_MA_E              ; jump si output_MA_DIS borramos todas las sal
     294 00000178                 level_motorB_step_time:
     295 00000178 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     296 00000180 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     297 00000184 000000D308E103    QBBS  STEP_PERIOD_B, r1, OUTPUT_MB_E                  ; jump is output_MB_E is set bit8
     298 00000188 000000CB08E10E    QBBC  DISABLE_OUTPUT_MB, r1, OUTPUT_MB_E              ; jump si output_MB_DIS borramos todas las sal
     299 0000018c                 level_motorC_step_time:
     300 0000018c C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     301 00000194 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     302 00000198 000000D30AE112    QBBS  STEP_PERIOD_C, r1, OUTPUT_MC_E                  ; jump is output_MC_E is set bit10
     303 0000019c 000000CB0AE11D    QBBC  DISABLE_OUTPUT_MC, r1, OUTPUT_MC_E              ; jump si output_MC_DIS borramos todas las sal
     304 000001a0                 level_motorD_step_time:
     305 000001a0 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     306 000001a8 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     307 000001ac 000000D30CE121    QBBS  STEP_PERIOD_D, r1, OUTPUT_MD_E                  ; jump is output_MD_E is set bit12
     308 000001b0 000000CB0CE12C    QBBC  DISABLE_OUTPUT_MD, r1, OUTPUT_MD_E              ; jump si output_MD_DIS borramos todas las sal
     309
     310 000001b4                 level_motorA_disable:
     311 000001b4 7138802444E0C0    LDI32 r0, (GPIO0|GPIO_DATAIN)                         ;
     312 000001bc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     313 000001c0 000000D316E130    QBBS  DISABLE_MA, r1, GPIO0_22_INPUT_MA_DISABLE       ; Desabilita el motor_A si GPIO0_22 is set
     314 000001c4                 level_motorA_toggle:
     315 000001c4 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     316 000001cc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     317 000001d0 000000D317E132    QBBS  TOGGLE_DIR_MA, r1, GPIO0_23_INPUT_MA_TOGGLE_DIR ; toggle direction el motor_MA si flanco GPIO0
     318 000001d4                 level_motorB_disable:
     319 000001d4 7138802444E0C0    LDI32 r0, (GPIO0|GPIO_DATAIN)                         ;
     320 000001dc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     321 000001e0 000000D31AE13B    QBBS  DISABLE_MB, r1, GPIO0_26_INPUT_MB_DISABLE       ; Desabilita el motor_MB si GPIO0_26 is set
     322 000001e4                 level_motorB_toggle:
     323 000001e4 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     324 000001ec 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     325 000001f0 000000D31BE13E    QBBS  TOGGLE_DIR_MB, r1, GPIO0_27_INPUT_MB_TOGGLE_DIR ; toggle direction el motor_MB si flanco GPIO0
     326
     327  ; limpiamos las interrupciones que quedaron sin limpiar
     328  ; clear IRQ_GPIO_IRQSTATUS_1
     329 000001f4 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     330 000001fc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    7

     331 00000200 0000001F16E1E1    SET   r1, r1, GPIO0_22_INPUT_MA_DISABLE               ;
     332 00000204 0000001F1AE1E1    SET   r1, r1, GPIO0_26_INPUT_MB_DISABLE               ;
     333 00000208 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     334
     335 0000020c 0000007F0000C4    QBA   MAIN_LOOP                                       ; program loop
     336
     337 00000210                 GPIO_INPUT_MODE0:
     338; clr flag gpio_input
     339 00000210 000000F1003480    LBBO  &r0, r20, SHD_GPIO_INPUT_MODE0_FLAG, 4          ;
     340 00000214 0000001D00E0E0    CLR   r0,r0, GPIO_INPUT_MODE0_FLAG                    ;
     341 00000218 000000E1003480    SBBO  &r0, r20, SHD_GPIO_INPUT_MODE0_FLAG, 4          ;
     342; read GPIO IN
     343 0000021c 7138802444E0C0    LDI32 r0, (GPIO0|GPIO_DATAIN)                         ;
     344 00000224 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     345; write GPIO IN DATA INTO SHARED
     346 00000228 0F0080240000C0    LDI32 r0, 0xF00                                       ; mascara desde bit8 a bit11 porque en el regi
     347 00000230 00000010E0E1E1    AND   r1, r1, r0                                      ;
     348 00000234 0000000B08E1E1    LSR   r1, r1, 8                                       ; se desplazan 8 posiciones para que los datos
     349; set flag data ready
     350 00000238 0000001F0CE1E1    SET   r1, r1, GPIO_INPUT_MODE0_DATARDY_FLAG           ; bit12-> flag data ready
     351 0000023c 000000E1043481    SBBO  &r1, r20, SHD_GPIO_INPUT_MODE0_DATA, 4          ; Cargamos valores de las entradas gpio_read b
     352 00000240 0000007F0000B9    QBA   level_gpio_input_mode1                          ;
     353
     354 00000244                 GPIO_INPUT_MODE1:
     355; no clr flag shared[0]para que quede continuamente leyendo
     356; get irq status
     357 00000244 C0308024481AC0    LDI32 r0, (GPIO2|GPIO_IRQSTATUS_1)
     358 0000024c 000000F1002081    LBBO  &r1, r0, 0, 4
     359 00000250 000000D102E102    QBBS  GPIO_INPUT_MODE1_A, r1, GPIO2_2_INPUT_GPIO_INPUT_TRIGGER
     360 00000254 0000007F0000B6    QBA   level_gpio_input_mode2
     361 00000258                 GPIO_INPUT_MODE1_A:
     362;  CLR   r30, pruout_fs_sample_test
     363; clear IRQ_GPIO_IRQSTATUS_1
     364 00000258 C0308024481AC0    LDI32 r0, (GPIO2|GPIO_IRQSTATUS_1)                    ;
     365 00000260 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     366 00000264 0000001F02E1E1    SET   r1, r1, GPIO2_2_INPUT_GPIO_INPUT_TRIGGER        ;
     367 00000268 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     368; read GPIO IN
     369 0000026c 7138802444E0C0    LDI32 r0, (GPIO0|GPIO_DATAIN)                         ;
     370 00000274 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     371; write GPIO IN DATA INTO SHARED
     372 00000278 0F0080240000C0    LDI32 r0, 0xF00                                       ; mascara desde bit8 a bit11 porque en el regi
     373 00000280 00000010E0E1E1    AND   r1, r1, r0                                      ;
     374 00000284 0000000B08E1E1    LSR   r1, r1, 8                                       ; se desplazan 8 posiciones para que los datos
     375; set flag rising detect
     376 00000288 0000001F0CE1E1    SET   r1, r1, GPIO_INPUT_MODE1_DATARDY_FLAG           ; bit12-> flag rising detect
     377 0000028c 000000E10C3481    SBBO  &r1, r20, SHD_GPIO_INPUT_MODE1_DATA, 4          ; Cargamos valores de las entradas gpio_read b
     378 00000290 0000007F0000A7    QBA   level_gpio_input_mode2                          ;
     379
     380 00000294                 GPIO_INPUT_MODE2:
     381; no clr flag shared[0]para que quede continuamente leyendo
     382; get irq status
     383 00000294 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     384 0000029c 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     385 000002a0 000000D108E105    QBBS  GPIO_INPUT_MODE2_A, r1, GPIO0_8_GPIO_INPUT_0    ; si se detecta flanco asc
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    8

     386 000002a4 000000D109E104    QBBS  GPIO_INPUT_MODE2_A, r1, GPIO0_9_GPIO_INPUT_1    ;
     387 000002a8 000000D10AE103    QBBS  GPIO_INPUT_MODE2_A, r1, GPIO0_10_GPIO_INPUT_2   ;
     388 000002ac 000000D10BE102    QBBS  GPIO_INPUT_MODE2_A, r1, GPIO0_11_GPIO_INPUT_3   ;
     389 000002b0 0000007F0000A1    QBA   level_gpio_output_mode0                         ;
     390 000002b4                 GPIO_INPUT_MODE2_A:
     391; clear IRQ_GPIO_IRQSTATUS_1
     392 000002b4 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     393 000002bc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     394 000002c0 0000001F08E1E1    SET   r1, r1, GPIO0_8_GPIO_INPUT_0                    ; borramos todas las interrupciones
     395 000002c4 0000001F09E1E1    SET   r1, r1, GPIO0_9_GPIO_INPUT_1                    ;
     396 000002c8 0000001F0AE1E1    SET   r1, r1, GPIO0_10_GPIO_INPUT_2                   ;
     397 000002cc 0000001F0BE1E1    SET   r1, r1, GPIO0_11_GPIO_INPUT_3                   ;
     398 000002d0 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     399; read GPIO IN
     400 000002d4 7138802444E0C0    LDI32 r0, (GPIO0|GPIO_DATAIN)                         ;
     401 000002dc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     402; write GPIO IN DATA INTO SHARED
     403 000002e0 0F0080240000C0    LDI32 r0, 0xF00                                       ; mascara desde bit8 a bit11 porque en el regi
     404 000002e8 00000010E0E1E1    AND   r1, r1, r0                                      ;
     405 000002ec 0000000B08E1E1    LSR   r1, r1, 8                                       ; se desplazan 8 posiciones para que los datos
     406; set flag rising detect
     407 000002f0 0000001F0CE1E1    SET   r1, r1, GPIO_INPUT_MODE2_DATARDY_FLAG           ; bit12-> flag rising detect
     408 000002f4 000000E1143481    SBBO  &r1, r20, SHD_GPIO_INPUT_MODE2_DATA, 4          ; Cargamos valores de las entradas gpio_read b
     409 000002f8 0000007F00008F    QBA   level_gpio_output_mode0                         ;
     410
     411 000002fc                 GPIO_OUTPUT_MODE0:
     412; clr flag gpio_output
     413 000002fc 000000F1183480    LBBO  &r0, r20, SHD_GPIO_OUTPUT_MODE0_FLAG, 4         ;
     414 00000300 0000001D00E0E0    CLR   r0, r0, GPIO_OUTPUT_MODE0_FLAG                  ;
     415 00000304 000000E1183480    SBBO  &r0, r20, SHD_GPIO_OUTPUT_MODE0_FLAG, 4         ;
     416; read GPIO_DATAOUT
     417 00000308 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     418 00000310 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     419; write GPIO DATAOUT INTO SHARED
     420 00000314 0000802403C0C0    LDI32 r0, 0x03C00000                                  ; mascara desde bit22 a bit25 porque en el reg
     421 0000031c 00000010E0E1E1    AND   r1, r1, r0                                      ;
     422 00000320 0000000B12E1E1    LSR   r1, r1, 18                                      ; se desplazan 18 posiciones para que los dato
     423; set flag data ready
     424 00000324 0000001F0CE1E1    SET   r1, r1, GPIO_OUTPUT_MODE0_DATARDY_FLAG          ; bit12-> flag gpio_output get complete
     425 00000328 000000E11C3481    SBBO  &r1, r20, SHD_GPIO_OUTPUT_MODE0_DATA, 4         ; Cargamos valores de gpio_out 22-25 en los bi
     426 0000032c 0000007F000084    QBA   level_gpio_output_mode1                         ;
     427
     428 00000330                 GPIO_OUTPUT_MODE1:
     429;  CLR   r30, pruout_fs_sample_test
     430; clr flag gpio_write
     431 00000330 000000F1203480    LBBO  &r0, r20, SHD_GPIO_OUTPUT_MODE1_FLAG, 4         ;
     432 00000334 0000001D00E0E0    CLR   r0, r0, GPIO_OUTPUT_MODE1_FLAG                  ; bit4 flag gpio_output set
     433 00000338 000000E1203480    SBBO  &r0, r20, SHD_GPIO_OUTPUT_MODE1_FLAG, 4         ;
     434; read gpio_output to set
     435 0000033c 000000F1243480    LBBO  &r0, r20, SHD_GPIO_OUTPUT_MODE1_DATA, 4         ;
     436 00000340 000000110FE0E1    AND   r1, r0, 0x0F                                    ; extrae los primeros 4 bits (0-3) en r1. Flag
     437 00000344 00000011F0E0E2    AND   r2, r0, 0xF0                                    ; extrae los bits 4-7 en r2. Pin state
     438 00000348 0000000B04E2E2    LSR   r2, r2, 4                                       ; desplaza los bits 4-7 a la posicion menos si
     439 0000034c 000083240000C3    LDI32 r3, 0                                           ; inicializa el contador de bits (0 a 3)
     440 00000354 000084240040C4    LDI32 r4, GPIO_OUT_BASE                               ; direccion base GPIO_OUT_BASE
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    9

     441 0000035c                 check_bits_w:
     442 0000035c 0000001101E2E5    AND   r5, r2, 1                                       ; extrae el bit menos significativo de r2 (sta
     443 00000360 000000D0E3E109    QBBS  gpio_write_out_funct, r1, r3                    ; qbbs myLabel r1, r3. Branch if( r1&(1<<r3) )
     444 00000364                 GPIO_OUTPUT_MODE1_A:
     445 00000364 0000000B01E2E2    LSR   r2, r2, 1                                       ; desplaza r2 a la derecha para procesar el si
     446 00000368 0000000901E4E4    LSL   r4, r4, 1                                       ; desplaza hacia el proximo bit de GPIO_out1,.
     447 0000036c 0000000101E3E3    ADD   r3, r3, 1                                       ; count++
     448 00000370 0000006704E3FB    QBGT  check_bits_w, r3, 4                             ; cuatro salidas. qbgt myLabel, r3, r4. Branch
     449; set flag data complete
     450 00000374 0000002EFF8180    ZERO  &r0, 4                                          ; shared erase
     451 00000378 0000001F0CE0E0    SET   r0, r0, GPIO_OUTPUT_MODE1_DATARDY_FLAG          ; shared bit12-> flag write complete
     452 0000037c 000000E1243480    SBBO  &r0, r20, SHD_GPIO_OUTPUT_MODE1_DATA, 4         ;
     453 00000380 0000007F000071    QBA   level_motor_mode0                               ;
     454
     455 00000384                 gpio_write_out_funct:
     456 00000384 000000D100E502    QBBS  write_out_set, r5, 0                            ; jamp si bit0 de r5 es set
     457 00000388 000000C900E505    QBBC  write_out_clr, r5, 0                            ; jamp si bit0 de r5 es clr
     458 0000038c                 write_out_set:
     459 0000038c C1948624481AC6    LDI32 r6, (GPIO2|GPIO_SETDATAOUT)                     ; load addr for GPIO Set data r6
     460 00000394 000000E1002684    SBBO  &r4, r6, 0, 4                                   ; write r4 to the r6 address valu
     461 00000398 0000007F0000F3    QBA   GPIO_OUTPUT_MODE1_A                             ;
     462 0000039c                 write_out_clr:
     463 0000039c C1908624481AC6    LDI32 r6, (GPIO2|GPIO_CLRDATAOUT)                     ; load addr for GPIO Clear data.
     464 000003a4 000000E1002684    SBBO  &r4, r6, 0, 4                                   ; write r4 to the r6 address
     465 000003a8 0000007F0000EF    QBA   GPIO_OUTPUT_MODE1_A                             ;
     466
     467 000003ac                 MOTOR_MODE0:
     468; clr flag motor config get
     469 000003ac 000000F1283480    LBBO  &r0, r20, SHD_MOTOR_MODE0_FLAG, 4               ;
     470 000003b0 0000001D00E0E0    CLR   r0,r0, MOTOR_MODE0_FLAG                         ; bit5 flag get state
     471 000003b4 000000E1283480    SBBO  &r0, r20, SHD_MOTOR_MODE0_FLAG, 4               ;
     472; read MOTOR
     473 000003b8 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for DATAOUT
     474 000003c0 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     475; write GPIO IN DATA INTO SHARED
     476 000003c4 3FC080240000C0    LDI32 r0, 0x03FC0                                     ; mascara desde bit6-13 para sacar enable-dir 
     477 000003cc 00000010E0E1E1    AND   r1, r1, r0                                      ;
     478 000003d0 0000000B02E1E1    LSR   r1, r1, 2                                       ; se desplazan 2 posiciones para que los datos
     479; set flag data ready
     480 000003d4 0000001F0CE1E1    SET   r1, r1, MOTOR_MODE0_DATARDY_FLAG                ; bit12-> flag get
     481 000003d8 000000E12C3481    SBBO  &r1, r20, SHD_MOTOR_MODE0_DATA, 4               ; Cargamos valores enable-dir de todos los mot
     482 000003dc 0000007F00005C    QBA   level_motor_mode1                               ;
     483
     484 000003e0                 MOTOR_MODE1:
     485;  CLR   r30, pruout_fs_sample_test                     ; debug-> verificamos que estamos entrando a l
     486; no clr flag shared[0]para que quede continuamente leyendo
     487; get irq status
     488 000003e0 C0308024481AC0    LDI32 r0, (GPIO2|GPIO_IRQSTATUS_1)                    ;
     489 000003e8 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     490 000003ec 000000D103E102    QBBS  MOTOR_MODE1_A, r1, GPIO2_3_INPUT_MOTOR_TRIGGER  ; si se detecta flanco asc enviamos los estado
     491 000003f0 0000007F000059    QBA   level_motor_mode2                               ;
     492 000003f4                 MOTOR_MODE1_A:
     493;  CLR   r30, pruout_fs_sample_test
     494; clear IRQ_GPIO_IRQSTATUS_1
     495 000003f4 C0308024481AC0    LDI32 r0, (GPIO2|GPIO_IRQSTATUS_1)                    ;
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE   10

     496 000003fc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     497 00000400 0000001F03E1E1    SET   r1, r1, GPIO2_3_INPUT_MOTOR_TRIGGER             ;
     498 00000404 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     499; read MOTOR
     500 00000408 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     501 00000410 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     502; write GPIO IN DATA INTO SHARED
     503 00000414 3FC080240000C0    LDI32 r0, 0x03FC0                                     ; mascara desde bit6-13 para sacar enable-dir 
     504 0000041c 00000010E0E1E1    AND   r1, r1, r0                                      ;
     505 00000420 0000000B02E1E1    LSR   r1, r1, 2                                       ; se desplazan 2 posiciones para que los datos
     506; set flag data ready
     507 00000424 0000001F0CE1E1    SET   r1, r1, MOTOR_MODE1_DATARDY_FLAG                ; shared bit12-> flag motor_config get
     508 00000428 000000E1343481    SBBO  &r1, r20, SHD_MOTOR_MODE1_DATA, 4               ; Cargamos valores enable-dir de todos los mot
     509 0000042c 0000007F00004A    QBA   level_motor_mode2                               ;
     510
     511 00000430                 MOTOR_MODE2:
     512; no clr flag shared[0]para que quede continuamente leyendo
     513; get irq status
     514 00000430 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     515 00000438 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     516 0000043c 000000D116E105    QBBS  MOTOR_MODE2_A, r1, GPIO0_22_INPUT_MA_DISABLE    ; si se detecta flanco asc enviamos los estado
     517 00000440 000000D117E104    QBBS  MOTOR_MODE2_A, r1, GPIO0_23_INPUT_MA_TOGGLE_DIR ;
     518 00000444 000000D11AE103    QBBS  MOTOR_MODE2_A, r1, GPIO0_26_INPUT_MB_DISABLE    ;
     519 00000448 000000D11BE102    QBBS  MOTOR_MODE2_A, r1, GPIO0_27_INPUT_MB_TOGGLE_DIR ;
     520 0000044c 0000007F000044    QBA   level_motor_mode3                               ;
     521 00000450                 MOTOR_MODE2_A:
     522; no borramos las interrupciones lo hacemos despues de evaluar todas las funciones al final del main l
     523; read MOTOR
     524 00000450 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     525 00000458 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     526; write GPIO IN DATA INTO SHARED
     527 0000045c 3FC080240000C0    LDI32 r0, 0x03FC0                                     ; mascara desde bit6-13 para sacar enable-dir 
     528 00000464 00000010E0E1E1    AND   r1, r1, r0                                      ;
     529 00000468 0000000B02E1E1    LSR   r1, r1, 2                                       ; se desplazan 2 posiciones para que los datos
     530; set flag data ready
     531 0000046c 0000001F0CE1E1    SET   r1, r1, MOTOR_MODE2_DATARDY_FLAG                ; shared bit12-> flag motor_config get
     532 00000470 000000E13C3481    SBBO  &r1, r20, SHD_MOTOR_MODE2_DATA, 4               ; Cargamos valores enable-dir de todos los mot
     533 00000474 0000007F00003A    QBA   level_motor_mode3                               ;
     534
     535 00000478                 MOTOR_MODE3:
     536; Cargamos los step
     537 00000478 000000F148348A    LBBO  &r10, r20, SHD_MOTOR_STEP_PERIOD_A, 4           ; read shared STEP_PERIOD_A
     538 0000047c 000000F14C348B    LBBO  &r11, r20, SHD_MOTOR_STEP_PERIOD_B, 4           ; read shared STEP_PERIOD_B
     539 00000480 000000F150348C    LBBO  &r12, r20, SHD_MOTOR_STEP_PERIOD_C, 4           ; read shared STEP_PERIOD_C
     540 00000484 000000F154348D    LBBO  &r13, r20, SHD_MOTOR_STEP_PERIOD_D, 4           ; read shared STEP_PERIOD_C
     541; clr flag motor set
     542 00000488 000000F1403480    LBBO  &r0, r20, SHD_MOTOR_MODE3_FLAG, 4               ; Shared
     543 0000048c 0000001D00E0E0    CLR   r0,r0, MOTOR_MODE3_FLAG                         ; bit5 flag motor
     544 00000490 000000E1403480    SBBO  &r0, r20, SHD_MOTOR_MODE3_FLAG, 4               ;
     545; load data
     546 00000494 000000F1443480    LBBO  &r0, r20, SHD_MOTOR_MODE3_DATA, 4               ;
     547 00000498 000000110FE0E1    AND   r1, r0, 0x0F                                    ; extrae los priomeros 4 bits (0-3) en r1. Fla
     548 0000049c 0FF082240000C2    LDI32 r2, 0xFF0                                       ; mascara bit 4-11
     549 000004a4 00000010E2E0E2    AND   r2, r0, r2                                      ; extrae los bits 4-11 en r2. Pins enable-dir
     550 000004a8 0000000B04E2E2    LSR   r2, r2, 4                                       ; desplaza los bits 4-11 a la posicion menos s
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE   11

     551 000004ac 000083240000C3    LDI32 r3, 0                                           ; inicializa el contador de bits (0 a 3)
     552 000004b4 004084240000C4    LDI32 r4, GPIO_MOTOR_ENA_BASE                         ; direccion base gpio MOTOR_ENA_Base
     553 000004bc 008085240000C5    LDI32 r5, GPIO_MOTOR_DIR_BASE                         ; direccion base gpio MOTOR_DIR_Base
     554 000004c4                 check_bits_m:
     555 000004c4 0000001103E2E6    AND   r6, r2, 0x03                                    ; extrae los dos primeros  bits. Bit0 -> Enabl
     556 000004c8 000000D0E3E10A    QBBS  motor_config, r1, r3                            ; qbbs myLabel r2, r4. Branch if( r2&(1<<r4) )
     557 000004cc                 MOTOR_MODE3_A1:
     558 000004cc 0000000B02E2E2    LSR   r2, r2, 2                                       ; desplaza r2 a la derecha para procesar los s
     559 000004d0 0000000902E4E4    LSL   r4, r4, 2                                       ; desplaza a la siguiente Ena
     560 000004d4 0000000902E5E5    LSL   r5, r5, 2                                       ; desplaza a la siguente Dir
     561 000004d8 0000000101E3E3    ADD   r3, r3, 1                                       ; count++
     562 000004dc 0000006704E3FA    QBGT  check_bits_m, r3, 4                             ; cuatro salidas. qbgt myLabel, r3, r4. Branch
     563; set flag motor config complete
     564 000004e0 0000002EFF8180    ZERO  &r0, 4                                          ; shared erase
     565 000004e4 0000001F0CE0E0    SET   r0, r0, MOTOR_MODE3_DATARDY_FLAG                ; shared bit12-> flag motor config complete
     566 000004e8 000000E1443480    SBBO  &r0, r20, SHD_MOTOR_MODE3_DATA, 4               ;
     567 000004ec 0000007F00001E    QBA   level_motorA_step_time                          ;
     568
     569 000004f0                 motor_config:
     570 000004f0 000000D100E604    QBBS  enable_set, r6, 0                               ;
     571 000004f4 000000C900E607    QBBC  enable_clr, r6, 0                               ;
     572 000004f8                 MOTOR_MODE3_A2:
     573 000004f8 000000D101E60A    QBBS  dir_set, r6, 1                                  ;
     574 000004fc 000000C901E60D    QBBC  dir_clr, r6, 1                                  ;
     575 00000500                 enable_set:
     576 00000500 C1948724481AC7    LDI32 r7, (GPIO2|GPIO_SETDATAOUT)                     ; load addr for GPIO Set data r7
     577 00000508 000000E1002784    SBBO  &r4, r7, 0, 4                                   ; write r4 to the r7 address value
     578 0000050c 0000007F0000FB    QBA   MOTOR_MODE3_A2                                  ;
     579 00000510                 enable_clr:
     580 00000510 C1908724481AC7    LDI32 r7, (GPIO2|GPIO_CLRDATAOUT)                     ; load addr for GPIO Set data r7
     581 00000518 000000E1002784    SBBO  &r4, r7, 0, 4                                   ; write r4 to the r6 address value
     582 0000051c 0000007F0000F7    QBA   MOTOR_MODE3_A2                                  ;
     583 00000520                 dir_set:
     584 00000520 C1948724481AC7    LDI32 r7, (GPIO2|GPIO_SETDATAOUT)                     ; load addr for GPIO Set data r7
     585 00000528 000000E1002785    SBBO  &r5, r7, 0, 4                                   ; write r5 to the r7 address value
     586 0000052c 0000007F0000E8    QBA   MOTOR_MODE3_A1                                  ;
     587 00000530                 dir_clr:
     588 00000530 C1908724481AC7    LDI32 r7, (GPIO2|GPIO_CLRDATAOUT)                     ; load addr for GPIO Set data r7
     589 00000538 000000E1002785    SBBO  &r5, r7, 0, 4                                   ; write r5 to the r7 address value
     590 0000053c 0000007F0000E4    QBA   MOTOR_MODE3_A1                                  ;
     591
     592 00000540                 STEP_PERIOD_A:
     593 00000540 0000000501EAEA    SUB   r10, r10, 1                                     ; se resta 1 a r10. r10 fue cargado cuando se 
     594 00000544 0000005100EA02    QBEQ  TOGGLE_PIN_A, r10, 0                            ; toggle pin step cuando la cuenta llega a 0
     595 00000548 0000007F00000C    QBA   level_motorB_step_time                          ; sino volvemos al loop principal
     596 0000054c                 TOGGLE_PIN_A:
     597 0000054c C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
     598 00000554 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     599 00000558 400082240000C2    LDI32 r2, OUTPUT_MA_S                                 ; GPIO2_14_MA_S
     600 00000560 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle GPIO2_14_MA_S
     601 00000564 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos la salida GPIO2_14_MA_S
     602 00000568 000000F148348A    LBBO  &r10, r20, SHD_MOTOR_STEP_PERIOD_A, 4           ; cargamos nuevamente el valor de shared[4] pa
     603 0000056c 0000007F000003    QBA   level_motorB_step_time                          ; volvemos al loop principal
     604
     605 00000570                 DISABLE_OUTPUT_MA:
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE   12

     606 00000570 C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ; recordar que hay que hacer un set para clr
     607 00000578 000081240000C1    LDI32 r1, 0x0                                         ; ponemos en estado bajo las salidas
     608 00000580 0000001F07E1E1    SET   r1, r1, OUTPUT_MA_D                             ;
     609 00000584 0000001F0EE1E1    SET   r1, r1, 14                                      ; OUTPUT_MA_S lo hacemos asi para no agregar m
     610 00000588 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     611 0000058c 0000007D0000FB    QBA   level_motorB_step_time                          ;
     612
     613 00000590                 STEP_PERIOD_B:
     614 00000590 0000000501EBEB    SUB   r11, r11, 1                                     ; se resta 1 a r11. r11 fue cargado cuando se 
     615 00000594 0000005100EB02    QBEQ  TOGGLE_PIN_B, r11, 0                            ; toggle pin step cuando la cuenta llega a 0
     616 00000598 0000007D0000FD    QBA   level_motorC_step_time                          ; sino volvemos al loop principal
     617 0000059c                 TOGGLE_PIN_B:
     618 0000059c C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
     619 000005a4 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     620 000005a8 800082240000C2    LDI32 r2, OUTPUT_MB_S                                 ; GPIO2_15_MB_S
     621 000005b0 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle GPIO2_15_MB_S
     622 000005b4 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos la salida GPIO2_15_MB_S
     623 000005b8 000000F14C348B    LBBO  &r11, r20, SHD_MOTOR_STEP_PERIOD_B, 4           ; cargamos nuevamente el valor de shared[5] pa
     624 000005bc 0000007D0000F4    QBA   level_motorC_step_time                          ; volvemos al loop principal
     625
     626 000005c0                 DISABLE_OUTPUT_MB:
     627 000005c0 C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ; recordar que hay que hacer un set para clr
     628 000005c8 000081240000C1    LDI32 r1, 0x0                                         ; ponemos en estado bajo las salidas
     629 000005d0 0000001F09E1E1    SET   r1, r1, OUTPUT_MB_D                             ;
     630 000005d4 0000001F0FE1E1    SET   r1, r1, 15                                      ; OUTPUT_MB_S
     631 000005d8 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     632 000005dc 0000007D0000EC    QBA   level_motorC_step_time                          ;
     633
     634 000005e0                 STEP_PERIOD_C:
     635 000005e0 0000000501ECEC    SUB   r12, r12, 1                                     ; se resta 1 a r12. r12 fue cargado cuando se 
     636 000005e4 0000005100EC02    QBEQ  TOGGLE_PIN_C, r12, 0                            ; toggle pin step cuando la cuenta llega a 0
     637 000005e8 0000007D0000EE    QBA   level_motorD_step_time                          ; sino volvemos al loop principal
     638 000005ec                 TOGGLE_PIN_C:
     639 000005ec C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
     640 000005f4 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     641 000005f8 000082240001C2    LDI32 r2, OUTPUT_MC_S                                 ; GPIO2_16_MC_S
     642 00000600 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle GPIO2_16_MC_S
     643 00000604 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos la salida GPIO2_16_MC_S
     644 00000608 000000F150348C    LBBO  &r12, r20, SHD_MOTOR_STEP_PERIOD_C, 4           ; cargamos nuevamente el valor de shared[6] pa
     645 0000060c 0000007D0000E5    QBA   level_motorD_step_time                          ; volvemos al loop principal
     646
     647 00000610                 DISABLE_OUTPUT_MC:
     648 00000610 C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ; recordar que hay que hacer un set para clr
     649 00000618 000081240000C1    LDI32 r1, 0x0                                         ; ponemos en estado bajo las salidas
     650 00000620 0000001F0BE1E1    SET   r1, r1, OUTPUT_MC_D                             ;
     651 00000624 0000001F10E1E1    SET   r1, r1, 16                                      ; OUTPUT_MC_S
     652 00000628 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     653 0000062c 0000007D0000DD    QBA   level_motorD_step_time                          ;
     654
     655 00000630                 STEP_PERIOD_D:
     656 00000630 0000000501EDED    SUB   r13, r13, 1                                     ; se resta 1 a r13. r13 fue cargado cuando se 
     657 00000634 0000005100ED02    QBEQ  TOGGLE_PIN_D, r13, 0                            ; toggle pin step cuando la cuenta llega a 0
     658 00000638 0000007D0000DF    QBA   level_motorA_disable                            ; sino volvemos al loop principal
     659 0000063c                 TOGGLE_PIN_D:
     660 0000063c C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE   13

     661 00000644 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     662 00000648 000082240002C2    LDI32 r2, OUTPUT_MD_S                                 ; GPIO2_17_MD_S
     663 00000650 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle GPIO2_17_MD_S
     664 00000654 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos la salida GPIO2_17_MD_S
     665 00000658 000000F154348D    LBBO  &r13, r20, SHD_MOTOR_STEP_PERIOD_D, 4           ; cargamos nuevamente el valor de shared[7] pa
     666 0000065c 0000007D0000D6    QBA   level_motorA_disable                            ; volvemos al loop principal
     667
     668 00000660                 DISABLE_OUTPUT_MD:
     669 00000660 C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ; recordar que hay que hacer un set para clr
     670 00000668 000081240000C1    LDI32 r1, 0x0                                         ; ponemos en estado bajo las salidas
     671 00000670 0000001F0DE1E1    SET   r1, r1, OUTPUT_MD_D                             ;
     672 00000674 0000001F11E1E1    SET   r1, r1, 17                                      ; OUTPUT_MD_S
     673 00000678 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     674 0000067c 0000007D0000CE    QBA   level_motorA_disable                            ;
     675
     676 00000680                 DISABLE_MA:
     677 00000680 C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ;
     678 00000688 004081240000C1    LDI32 r1, GPIO_MOTOR_ENA_BASE                         ; direccion base gpio MOTOR_ENA_Base Motor_MA
     679 00000690 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     680 00000694 0000007D0000CC    QBA   level_motorA_toggle                             ;
     681
     682 00000698                 TOGGLE_DIR_MA:
     683; toggle drection pins
     684 00000698 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
     685 000006a0 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     686 000006a4 008082240000C2    LDI32 r2, GPIO_MOTOR_DIR_BASE                         ;
     687 000006ac 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle
     688 000006b0 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos dir
     689; clear IRQ_GPIO_IRQSTATUS_1
     690 000006b4 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ; load addr for GPIO2
     691 000006bc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     692 000006c0 0000001F17E1E1    SET   r1, r1, GPIO0_23_INPUT_MA_TOGGLE_DIR            ;
     693 000006c4 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     694 000006c8 0000007D0000C3    QBA   level_motorB_disable                            ; volvemos al loop principal
     695
     696 000006cc                 DISABLE_MB:
     697 000006cc C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ;
     698 000006d4 004081240000C1    LDI32 r1, GPIO_MOTOR_ENA_BASE                         ; direccion gpio MOTOR_ENA_Base Motor_MB
     699 000006dc 0000000902E1E1    LSL   r1, r1, 2                                       ; hay que moverse 2 posiciones Enable motor_MB
     700 000006e0 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     701 000006e4 0000007D0000C0    QBA   level_motorB_toggle                             ;
     702
     703 000006e8                 TOGGLE_DIR_MB:
     704; toggle direction pins
     705 000006e8 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
     706 000006f0 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     707 000006f4 008082240000C2    LDI32 r2, GPIO_MOTOR_DIR_BASE                         ;
     708 000006fc 0000000902E2E2    LSL   r2, r2, 2                                       ;
     709 00000700 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle
     710 00000704 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos la salida
     711; clear IRQ_GPIO_IRQSTATUS_1
     712 00000708 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ; load addr for GPIO2
     713 00000710 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     714 00000714 0000001F1BE1E1    SET   r1, r1, GPIO0_27_INPUT_MB_TOGGLE_DIR            ;
     715 00000718 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
PRU Assembler Unix v2.3.3 Sun Apr 13 13:17:15 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE   14

     716 0000071c 0000007D000080    QBA   MAIN_LOOP                                       ; volvemos al loop principal
     717
     718 00000720 00239F240000DF    LDI32   R31, (PRU0_R31_VEC_VALID|PRU_EVTOUT_0)        ;
     719 00000728 0000002A000000    HALT                                                  ; halt the pru program

No Assembly Errors, No Assembly Warnings
