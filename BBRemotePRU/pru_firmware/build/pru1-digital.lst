PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    1

       1; Raul Emlio Romero
       2;
       3; cd /sys/class/remoteproc/remoteproc2
       4; echo 'am335x-pru1-digital-fw' > firmware
       5; echo 'start' > state
       6; echo 'stop' > state
       7; cd /sys/kernel/debug/remoteproc/remoteproc2
       8; sudo cat regs
       9;
      10; PRU definitions
      11
      12; pru1Control
      13  .asg 0x22000, PRU0_CTRL
      14  .asg 0x24000, PRU1_CTRL                               ; page 19
      15  .asg 0x28, CTPPR0                                     ; page 75
      16
      17; memory
      18  .asg 0x00000000, RAM0_ADDR                            ; local addr ram0. In linux space addr is 0x4a
      19  .asg 0x00002000, RAM1_ADDR                            ; local addr ram1. In linux space addr is 0x4a
      20  .asg 0x00010000, SHARED_ADDR                          ; local addr shared. In linux space addr is 0x
      21
      22  .asg 0x00, SHD_FLAGS                                  ; shared[0] flags linux
      23  .asg 0x04, SHD_GPIO_INPUT_MODE0_DATA                  ; shared[1] gpio_input mode 0
      24  .asg 0x08, SHD_GPIO_INPUT_MODE1_DATA                  ; shared[2] gpio_input mode 1
      25  .asg 0x0C, SHD_GPIO_INPUT_MODE2_DATA                  ; shared[3] gpio_input mode 2
      26  .asg 0x10, SHD_GPIO_OUTPUT_MODE0_DATA                 ; shared[4] gpio_output mode 0
      27  .asg 0x14, SHD_GPIO_OUTPUT_MODE1_DATA                 ; shared[5] gpio_output mode 1
      28  .asg 0x18, SHD_MOTOR_MODE0_DATA                       ; shared[6] motor mode 0
      29  .asg 0x1C, SHD_MOTOR_MODE1_DATA                       ; shared[7] motor mode 1
      30  .asg 0x20, SHD_MOTOR_MODE2_DATA                       ; shared[8] motor mode 2
      31  .asg 0x24, SHD_MOTOR_MODE3_DATA                       ; shared[9] motor mode 3
      32  .asg 0x28, SHD_MOTOR_STEP_PERIOD_A                    ; shared[10] motor_A STEP_PERIOD_A
      33  .asg 0x2C, SHD_MOTOR_STEP_PERIOD_B                    ; shared[11] motor_B STEP_PERIOD_B
      34  .asg 0x30, SHD_MOTOR_STEP_PERIOD_C                    ; shared[12] motor_C STEP_PERIOD_C
      35  .asg 0x34, SHD_MOTOR_STEP_PERIOD_D                    ; shared[13] motor_D STEP_PERIOD_D
      36
      37  .asg 0x0F, SHARED_MEM_SIZE                            ; 15 en decimal
      38  .asg 0x04, OFFSET_MEM                                 ;
      39
      40; gpio bank
      41  .asg 0x44e07000, GPIO0                                ; GPIO Bank 0, See the AM335x TRM
      42  .asg 0x481ac000, GPIO2                                ; GPIO Bank 2
      43
      44  .asg 0x190, GPIO_CLRDATAOUT                           ; for clearing the GPIO registers
      45  .asg 0x194, GPIO_SETDATAOUT                           ; for setting the GPIO registers
      46  .asg 0x13C, GPIO_DATAOUT                              ; for read-write the GPIO registers
      47  .asg 0x138, GPIO_DATAIN                               ; for reading the GPIO registers
      48  .asg 0x38,  GPIO_IRQSTATUS_SET_1                      ; habilita las interrupciones por set
      49  .asg 0x148, GPIO_RISINGDETECT                         ; habilita las interrupciones por flanco asc
      50  .asg 0x30,  GPIO_IRQSTATUS_1                          ; get-set irq
      51  .asg 0x150, GPIO_DEBOUNCENABLE                        ; antirebote enable register
      52  .asg 0x54,  GPIO_DEBOUNCINGTIME                       ; configure debouncingtime register
      53  .asg 0xD,  DEBOUNCETIME                               ; Debouncing Value = (DEBOUNCETIME + 1) * 31 m
      54  .asg 0xF00, GPIO0_LEVELDETECT_MASK                    ; bits 8-11 estas entradas estan configuradas 
      55  .asg 0x08800000, GPIO0_RISINGDETECT_MASK              ; bit23 y bit 27
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    2

      56  .asg 0x0C, GPIO2_RISINGDETECT_MASK                    ; bit2 y bit3
      57
      58  .asg 0x130, GPIO_CTRL                                 ; enable GPIO port
      59  .asg 0x00,  GPIO_CTRL_ENABLE                          ;
      60  .asg 0x134, GPIO_OE                                   ; set GPIO input - output
      61  .asg 0xFC3C003F, GPIO2_OE_IN_OUT                      ; pines usados como salida bit6 a bit17 y bit2
      62  .asg 0x0CC00F00, GPIO0_OE_IN_OUT                      ; pines usados como entrada bits8-11, bits22-2
      63
      64; gpio_read
      65  ; Pins
      66  .asg 8,  GPIO0_8_GPIO_INPUT_0                         ; P8_35 gpio0[8] -> bit8 input_0  no hace falt
      67  .asg 9,  GPIO0_9_GPIO_INPUT_1                         ; P8_33 gpio0[9] -> bit9 input_1  no hace falt
      68  .asg 10, GPIO0_10_GPIO_INPUT_2                        ; P8_31 gpio0[10]-> bit10 input_2 no hace falt
      69  .asg 11, GPIO0_11_GPIO_INPUT_3                        ; P8_32 gpio0[11]-> bit11 input_3 no hace falt
      70
      71  ; MOTOR_A hardware pins
      72  .asg 22, GPIO0_22_INPUT_MA_DISABLE                    ; P8_19 gpio0[22]-> bit22 input_MA_E set disab
      73  .asg 23, GPIO0_23_INPUT_MA_TOGGLE_DIR                 ; P8_13 gpio0[23]-> bit23 input_MA_D set toogl
      74  ; MOTOR_B hardware pins
      75  .asg 26, GPIO0_26_INPUT_MB_DISABLE                    ; P8_14 gpio0[26]-> bit26 input_MB_E set disab
      76  .asg 27, GPIO0_27_INPUT_MB_TOGGLE_DIR                 ; P8_17 gpio0[27]-> bit27 input_MB_D set toogl
      77
      78  ; TRIGGER RESING DETECT
      79  .asg 2, GPIO2_2_INPUT_GPIO_INPUT_TRIGGER              ; P8_07 gpio2[2]-> bit2 input gpio_input send 
      80  .asg 3, GPIO2_3_INPUT_MOTOR_TRIGGER                   ; P8_08 gpio2[3]-> bit3 input motor send risin
      81
      82; gpio_write
      83  .asg  (1<<22),  GPIO_OUT_BASE                         ;
      84  ; Pins
      85  ; P8_27 gpio2[22]-> bit22 output_0 no hace falta hacer: config-pin P8_27 gpio
      86  ; P8_29 gpio2[23]-> bit23 output_1 no hace falta hacer: config-pin P8_29 gpio
      87  ; P8_28 gpio2[24]-> bit24 output_2 no hace falta hacer: config-pin P8_28 gpio
      88  ; P8_30 gpio2[25]-> bit25 output_3 no hace falta hacer: config-pin P8_30 gpio
      89
      90; motor
      91  ; Enable-Direction
      92  .asg (1<<6), GPIO_MOTOR_ENA_BASE                      ;
      93  .asg (1<<7), GPIO_MOTOR_DIR_BASE                      ;
      94
      95  ; Pins
      96  .asg 6, OUTPUT_MA_E                                   ; P8_45 gpio2[6] -> bit6 output_MA_E no hace f
      97  .asg 7, OUTPUT_MA_D                                   ; P8_46 gpio2[7] -> bit7 output_MA_D config-pi
      98
      99  .asg 8, OUTPUT_MB_E                                   ; P8_43 gpio2[8] -> bit8 output_MB_E config-pi
     100  .asg 9, OUTPUT_MB_D                                   ; P8_44 gpio2[9] -> bit9 output_MB_D config-pi
     101
     102  .asg 10, OUTPUT_MC_E                                  ; P8_41 gpio2[10]-> bit10 output_MC_E config-p
     103  .asg 11, OUTPUT_MC_D                                  ; P8_42 gpio2[11]-> bit11 output_MC_D config-p
     104
     105  .asg 12, OUTPUT_MD_E                                  ; P8_39 gpio2[12]-> bit12 output_MD_E config-p
     106  .asg 13, OUTPUT_MD_D                                  ; P8_40 gpio2[13]-> bit13 output_MD_D config-p
     107
     108  ; Step period (medio ciclo de la senial)
     109  .asg (1<<14), OUTPUT_MA_S                             ; P8_37 gpio2[14] output_MA_S no hace falta ha
     110  .asg (1<<15), OUTPUT_MB_S                             ; P8_38 gpio2[15] output_MB_S
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    3

     111  .asg (1<<16), OUTPUT_MC_S                             ; P8_36 gpio2[16] output_MC_S
     112  .asg (1<<17), OUTPUT_MD_S                             ; P8_34 gpio2[17] output_MD_S
     113
     114; functions flags
     115  .asg 0, GPIO_INPUT_MODE0_FLAG                         ; shared[0] bit0
     116  .asg 1, GPIO_INPUT_MODE1_FLAG                         ; shared[0] bit1
     117  .asg 2, GPIO_INPUT_MODE2_FLAG                         ; shared[0] bit2
     118  .asg 3, GPIO_OUTPUT_MODE0_FLAG                        ; shared[0] bit3
     119  .asg 4, GPIO_OUTPUT_MODE1_FLAG                        ; shared[0] bit4
     120  .asg 5, MOTOR_MODE0_FLAG                              ; shared[0] bit5
     121  .asg 6, MOTOR_MODE1_FLAG                              ; shared[0] bit6
     122  .asg 7, MOTOR_MODE2_FLAG                              ; shared[0] bit7
     123  .asg 8, MOTOR_MODE3_FLAG                              ; shared[0] bit8
     124
     125  .asg 12, GPIO_INPUT_MODE0_DATARDY_FLAG                ; shared[1] bit12
     126  .asg 12, GPIO_INPUT_MODE1_DATARDY_FLAG                ; shared[2] bit12
     127  .asg 12, GPIO_INPUT_MODE2_DATARDY_FLAG                ; shared[3] bit12
     128  .asg 12, GPIO_OUTPUT_MODE0_DATARDY_FLAG               ; shared[4] bit12
     129  .asg 12, GPIO_OUTPUT_MODE1_DATARDY_FLAG               ; shared[5] bit12
     130  .asg 12, MOTOR_MODE0_DATARDY_FLAG                     ; shared[6] bit12
     131  .asg 12, MOTOR_MODE1_DATARDY_FLAG                     ; shared[7] bit12
     132  .asg 12, MOTOR_MODE2_DATARDY_FLAG                     ; shared[8] bit12
     133  .asg 12, MOTOR_MODE3_DATARDY_FLAG                     ; shared[9] bit12
     134
     135  .asg 32, PRU0_R31_VEC_VALID                           ; allows notification of program completion
     136  .asg 3,  PRU_EVTOUT_0                                 ; the event number that is sent back
     137
     138  ; para ver pruout_fs_sample_test en debug hay que cargarlo en el PRU0
     139  ; porque en PRU1  se utilizaron todos los pines
     140  ;.asg r30.t5, pruout_fs_sample_test                   ; debug-> usando PRU usamos esta salida para v
     141
     142  .clink
     143  .global start
     144
     145 00000000                 start:
     146; Registro fijos
     147 00000000 000094240001D4    LDI32 r20, SHARED_ADDR                                ; shared_addr_base
     148  ; r10-> STEP_PERIOD_A
     149  ; r11-> STEP_PERIOD_B
     150  ; r12-> STEP_PERIOD_C
     151  ; r13-> STEP_PERIOD_D
     152  ; r21-r25-> DEBUG
     153
     154 00000008                 SETUP:
     155;  CLR   r30, pruout_fs_sample_test
     156; borrado de momoria
     157 00000008 0000002EFF8180    ZERO  &r0, 4                                          ; zero put register
     158 0000000c 000081240000C1    LDI32 r1, 0                                           ; offset_mem
     159 00000014 000082240000C2    LDI32 r2, 0                                           ; Count mem
     160 0000001c                 mem_init:
     161 0000001c 000000E0E13480    SBBO  &r0, r20, r1, 4                                 ;
     162 00000020 0000000104E1E1    ADD   r1, r1, 4                                       ; cada posicion de memoria ocupa 4 bytes
     163 00000024 0000000101E2E2    ADD   r2, r2, 1                                       ; count++
     164 00000028 000000670FE2FD    QBGT  mem_init, r2, SHARED_MEM_SIZE                   ; qbgt myLabel, r3, r4. Branch if r4 > r3
     165
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    4

     166 0000002c                 gpio_config:
     167;GPIO0
     168 0000002c 7130802444E0C0    LDI32 r0, (GPIO0|GPIO_CTRL)                           ; load GPIO0 control register address
     169 00000034 000081240000C1    LDI32 r1, GPIO_CTRL_ENABLE                            ; load control enable value
     170 0000003c 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; write enable value to GPIO0 control register
     171
     172 00000040 7134802444E0C0    LDI32 r0, (GPIO0|GPIO_OE)                             ; load GPIO0 output enable register address
     173 00000048 0F0081240CC0C1    LDI32 r1, GPIO0_OE_IN_OUT                             ; set GPIO0 as input
     174 00000050 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; write input configuration to GPIO0
     175
     176  ; pines flanco asc
     177 00000054 7148802444E0C0    LDI32 r0, (GPIO0|GPIO_RISINGDETECT)                   ; load addr for GPIO0
     178 0000005c 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     179 00000060 0000001F08E1E1    SET   r1, r1, GPIO0_8_GPIO_INPUT_0                    ;
     180 00000064 0000001F09E1E1    SET   r1, r1, GPIO0_9_GPIO_INPUT_1                    ;
     181 00000068 0000001F0AE1E1    SET   r1, r1, GPIO0_10_GPIO_INPUT_2                   ;
     182 0000006c 0000001F0BE1E1    SET   r1, r1, GPIO0_11_GPIO_INPUT_3                   ;
     183 00000070 0000001F16E1E1    SET   r1, r1, GPIO0_22_INPUT_MA_DISABLE               ;
     184 00000074 0000001F17E1E1    SET   r1, r1, GPIO0_23_INPUT_MA_TOGGLE_DIR            ;
     185 00000078 0000001F1AE1E1    SET   r1, r1, GPIO0_26_INPUT_MB_DISABLE               ;
     186 0000007c 0000001F1BE1E1    SET   r1, r1, GPIO0_27_INPUT_MB_TOGGLE_DIR            ;
     187;  LDI32 r1, GPIO0_RISINGDETECT_MASK                    ; input toggles bit23 y bit27
     188 00000080 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     189
     190  ; enable irq set_1
     191 00000084 7038802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_SET_1)                ; load addr for GPIO0
     192 0000008c 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     193 00000090 0000001F08E1E1    SET   r1, r1, GPIO0_8_GPIO_INPUT_0                    ;
     194 00000094 0000001F09E1E1    SET   r1, r1, GPIO0_9_GPIO_INPUT_1                    ;
     195 00000098 0000001F0AE1E1    SET   r1, r1, GPIO0_10_GPIO_INPUT_2                   ;
     196 0000009c 0000001F0BE1E1    SET   r1, r1, GPIO0_11_GPIO_INPUT_3                   ;
     197 000000a0 0000001F16E1E1    SET   r1, r1, GPIO0_22_INPUT_MA_DISABLE               ;
     198 000000a4 0000001F17E1E1    SET   r1, r1, GPIO0_23_INPUT_MA_TOGGLE_DIR            ;
     199 000000a8 0000001F1AE1E1    SET   r1, r1, GPIO0_26_INPUT_MB_DISABLE               ;
     200 000000ac 0000001F1BE1E1    SET   r1, r1, GPIO0_27_INPUT_MB_TOGGLE_DIR            ;
     201;  LDI32 r1, GPIO0_RISINGDETECT_MASK                    ; input toggles bit23 y bit27
     202 000000b0 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     203
     204  ; configuracion antirebote
     205;  LDI32 r0, (GPIO0|GPIO_DEBOUNCINGTIME)                ; load addr for GPIO0
     206;  LBBO  &r1, r0, 0, 4                                  ; Load the values at r0 into r1.
     207;  LDI32 r1, GPIO_DEBOUNCINGTIME                        ; debouncingtime 0-255
     208;  SBBO  &r1, r0, 0, 4                                  ; Load the values at r0 into r1.
     209
     210  ; Muy importante primero hay que definir el debouncingtime y luego habilitar el modulo
     211;  LDI32 r0, (GPIO0|GPIO_DEBOUNCENABLE)                 ; load addr for GPIO0
     212;  LBBO  &r1, r0, 0, 4                                  ; Load the values at r0 into r1.
     213;  LDI32 r1, 0x0                                        ;
     214;  LDI32 r1, GPIO0_LEVELDETECT_MASK                     ; input GPIO0 bits 8-11
     215;  SBBO  &r1, r0, 0, 4                                  ; Load the values at r0 into r1.
     216
     217;GPIO2
     218 000000b4 C1308024481AC0    LDI32 r0, (GPIO2|GPIO_CTRL)                           ; load GPIO2 control register address
     219 000000bc 000081240000C1    LDI32 r1, GPIO_CTRL_ENABLE                            ; load control enable value
     220 000000c4 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; write enable value to GPIO2 control register
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    5

     221
     222 000000c8 C1348024481AC0    LDI32 r0, (GPIO2|GPIO_OE)                             ; load GPIO2 output enable register address
     223 000000d0 003F8124FC3CC1    LDI32 r1, GPIO2_OE_IN_OUT                             ; set GPIO2 as output ojo aca tambien estamos 
     224 000000d8 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; write output configuration to GPIO2
     225
     226  ; rising detect
     227 000000dc C1488024481AC0    LDI32 r0, (GPIO2|GPIO_RISINGDETECT)                   ; load addr for GPIO2
     228 000000e4 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     229 000000e8 0000001F02E1E1    SET   r1, r1, GPIO2_2_INPUT_GPIO_INPUT_TRIGGER        ;
     230 000000ec 0000001F03E1E1    SET   r1, r1, GPIO2_3_INPUT_MOTOR_TRIGGER             ;
     231;  LDI32 r1, GPIO2_RISINGDETECT_MASK                    ; input bit1
     232 000000f0 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     233
     234  ; enable irq set_1
     235 000000f4 C0388024481AC0    LDI32 r0, (GPIO2|GPIO_IRQSTATUS_SET_1)                ; load addr for GPIO2
     236 000000fc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     237 00000100 0000001F02E1E1    SET   r1, r1, GPIO2_2_INPUT_GPIO_INPUT_TRIGGER        ;
     238 00000104 0000001F03E1E1    SET   r1, r1, GPIO2_3_INPUT_MOTOR_TRIGGER             ;
     239;  LDI32 r1, GPIO2_RISINGDETECT_MASK                    ; input bit1
     240 00000108 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     241
     242 0000010c C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load GPIO2 output
     243 00000114 0000002EFF8181    ZERO  &r1, 4                                          ;
     244 00000118 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; Cargamos todas las salidas en cero
     245
     246 0000011c                 MAIN_LOOP:
     247;  SET   r30, pruout_fs_sample_test
     248 0000011c                 level_gpio_input_mode0:
     249 0000011c 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     250 00000120 000000D100E03C    QBBS  GPIO_INPUT_MODE0, r0, GPIO_INPUT_MODE0_FLAG     ; jump is set bit0
     251 00000124                 level_gpio_input_mode1:
     252 00000124 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     253 00000128 000000D101E047    QBBS  GPIO_INPUT_MODE1, r0, GPIO_INPUT_MODE1_FLAG     ; jump is set bit1
     254 0000012c                 level_gpio_input_mode2:
     255 0000012c 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     256 00000130 000000D102E059    QBBS  GPIO_INPUT_MODE2, r0, GPIO_INPUT_MODE2_FLAG     ; jump is set bit2
     257
     258 00000134                 level_gpio_output_mode0:
     259 00000134 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     260 00000138 000000D103E071    QBBS  GPIO_OUTPUT_MODE0, r0, GPIO_OUTPUT_MODE0_FLAG   ; jump is set bit3
     261 0000013c                 level_gpio_output_mode1:
     262 0000013c 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     263 00000140 000000D104E07C    QBBS  GPIO_OUTPUT_MODE1, r0, GPIO_OUTPUT_MODE1_FLAG   ; jump is set bit4
     264
     265 00000144                 level_motor_mode0:
     266 00000144 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     267 00000148 000000D105E099    QBBS  MOTOR_MODE0, r0, MOTOR_MODE0_FLAG               ; jump is set bit5
     268 0000014c                 level_motor_mode1:
     269 0000014c 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     270 00000150 000000D106E0A4    QBBS  MOTOR_MODE1, r0, MOTOR_MODE1_FLAG               ; jump is set bit6
     271 00000154                 level_motor_mode2:
     272 00000154 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     273 00000158 000000D107E0B6    QBBS  MOTOR_MODE2, r0, MOTOR_MODE2_FLAG               ; jump is set bit7
     274 0000015c                 level_motor_mode3:
     275 0000015c 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    6

     276 00000160 000000D108E0C6    QBBS  MOTOR_MODE3, r0, MOTOR_MODE3_FLAG               ; jump is set bit8
     277
     278 00000164                 level_motorA_step_time:
     279 00000164 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     280 0000016c 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     281 00000170 000000D106E1F4    QBBS  STEP_PERIOD_A, r1, OUTPUT_MA_E                  ; jump is output_MA_E is set bit6
     282 00000174 000000C906E1FF    QBBC  DISABLE_OUTPUT_MA, r1, OUTPUT_MA_E              ; jump si output_MA_DIS borramos todas las sal
     283 00000178                 level_motorB_step_time:
     284 00000178 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     285 00000180 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     286 00000184 000000D308E103    QBBS  STEP_PERIOD_B, r1, OUTPUT_MB_E                  ; jump is output_MB_E is set bit8
     287 00000188 000000CB08E10E    QBBC  DISABLE_OUTPUT_MB, r1, OUTPUT_MB_E              ; jump si output_MB_DIS borramos todas las sal
     288 0000018c                 level_motorC_step_time:
     289 0000018c C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     290 00000194 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     291 00000198 000000D30AE112    QBBS  STEP_PERIOD_C, r1, OUTPUT_MC_E                  ; jump is output_MC_E is set bit10
     292 0000019c 000000CB0AE11D    QBBC  DISABLE_OUTPUT_MC, r1, OUTPUT_MC_E              ; jump si output_MC_DIS borramos todas las sal
     293 000001a0                 level_motorD_step_time:
     294 000001a0 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     295 000001a8 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     296 000001ac 000000D30CE121    QBBS  STEP_PERIOD_D, r1, OUTPUT_MD_E                  ; jump is output_MD_E is set bit12
     297 000001b0 000000CB0CE12C    QBBC  DISABLE_OUTPUT_MD, r1, OUTPUT_MD_E              ; jump si output_MD_DIS borramos todas las sal
     298
     299 000001b4                 level_motorA_disable:
     300 000001b4 7138802444E0C0    LDI32 r0, (GPIO0|GPIO_DATAIN)                         ;
     301 000001bc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     302 000001c0 000000D316E130    QBBS  DISABLE_MA, r1, GPIO0_22_INPUT_MA_DISABLE       ; Desabilita el motor_A si GPIO0_22 is set
     303 000001c4                 level_motorA_toggle:
     304 000001c4 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     305 000001cc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     306 000001d0 000000D317E132    QBBS  TOGGLE_DIR_MA, r1, GPIO0_23_INPUT_MA_TOGGLE_DIR ; toggle direction el motor_MA si flanco GPIO0
     307 000001d4                 level_motorB_disable:
     308 000001d4 7138802444E0C0    LDI32 r0, (GPIO0|GPIO_DATAIN)                         ;
     309 000001dc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     310 000001e0 000000D31AE13B    QBBS  DISABLE_MB, r1, GPIO0_26_INPUT_MB_DISABLE       ; Desabilita el motor_MB si GPIO0_26 is set
     311 000001e4                 level_motorB_toggle:
     312 000001e4 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     313 000001ec 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     314 000001f0 000000D31BE13E    QBBS  TOGGLE_DIR_MB, r1, GPIO0_27_INPUT_MB_TOGGLE_DIR ; toggle direction el motor_MB si flanco GPIO0
     315
     316  ; limpiamos las interrupciones que quedaron sin limpiar
     317  ; clear IRQ_GPIO_IRQSTATUS_1
     318 000001f4 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     319 000001fc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     320 00000200 0000001F16E1E1    SET   r1, r1, GPIO0_22_INPUT_MA_DISABLE               ;
     321 00000204 0000001F1AE1E1    SET   r1, r1, GPIO0_26_INPUT_MB_DISABLE               ;
     322 00000208 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     323
     324 0000020c 0000007F0000C4    QBA   MAIN_LOOP                                       ; program loop
     325
     326 00000210                 GPIO_INPUT_MODE0:
     327; clr flag gpio_input
     328 00000210 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     329 00000214 0000001D00E0E0    CLR   r0,r0, GPIO_INPUT_MODE0_FLAG                    ; bit0 flag gpio_input
     330 00000218 000000E1003480    SBBO  &r0, r20, SHD_FLAGS, 4                          ;
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    7

     331; read GPIO IN
     332 0000021c 7138802444E0C0    LDI32 r0, (GPIO0|GPIO_DATAIN)                         ;
     333 00000224 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     334; write GPIO IN DATA INTO SHARED
     335 00000228 0F0080240000C0    LDI32 r0, 0xF00                                       ; mascara desde bit8 a bit11 porque en el regi
     336 00000230 00000010E0E1E1    AND   r1, r1, r0                                      ;
     337 00000234 0000000B08E1E1    LSR   r1, r1, 8                                       ; se desplazan 8 posiciones para que los datos
     338; set flag data ready
     339 00000238 0000001F0CE1E1    SET   r1, r1, GPIO_INPUT_MODE0_DATARDY_FLAG           ; bit12-> flag data ready
     340 0000023c 000000E1043481    SBBO  &r1, r20, SHD_GPIO_INPUT_MODE0_DATA, 4          ; Cargamos valores de las entradas gpio_read b
     341 00000240 0000007F0000B9    QBA   level_gpio_input_mode1                          ;
     342
     343 00000244                 GPIO_INPUT_MODE1:
     344; no clr flag shared[0]para que quede continuamente leyendo
     345; get irq status
     346 00000244 C0308024481AC0    LDI32 r0, (GPIO2|GPIO_IRQSTATUS_1)
     347 0000024c 000000F1002081    LBBO  &r1, r0, 0, 4
     348 00000250 000000D102E102    QBBS  GPIO_INPUT_MODE1_A, r1, GPIO2_2_INPUT_GPIO_INPUT_TRIGGER
     349 00000254 0000007F0000B6    QBA   level_gpio_input_mode2
     350 00000258                 GPIO_INPUT_MODE1_A:
     351;  CLR   r30, pruout_fs_sample_test
     352; clear IRQ_GPIO_IRQSTATUS_1
     353 00000258 C0308024481AC0    LDI32 r0, (GPIO2|GPIO_IRQSTATUS_1)                    ;
     354 00000260 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     355 00000264 0000001F02E1E1    SET   r1, r1, GPIO2_2_INPUT_GPIO_INPUT_TRIGGER        ;
     356 00000268 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     357; read GPIO IN
     358 0000026c 7138802444E0C0    LDI32 r0, (GPIO0|GPIO_DATAIN)                         ;
     359 00000274 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     360; write GPIO IN DATA INTO SHARED
     361 00000278 0F0080240000C0    LDI32 r0, 0xF00                                       ; mascara desde bit8 a bit11 porque en el regi
     362 00000280 00000010E0E1E1    AND   r1, r1, r0                                      ;
     363 00000284 0000000B08E1E1    LSR   r1, r1, 8                                       ; se desplazan 8 posiciones para que los datos
     364; set flag rising detect
     365 00000288 0000001F0CE1E1    SET   r1, r1, GPIO_INPUT_MODE1_DATARDY_FLAG           ; bit12-> flag rising detect
     366 0000028c 000000E1083481    SBBO  &r1, r20, SHD_GPIO_INPUT_MODE1_DATA, 4          ; Cargamos valores de las entradas gpio_read b
     367 00000290 0000007F0000A7    QBA   level_gpio_input_mode2                          ;
     368
     369 00000294                 GPIO_INPUT_MODE2:
     370; no clr flag shared[0]para que quede continuamente leyendo
     371; get irq status
     372 00000294 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     373 0000029c 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     374 000002a0 000000D108E105    QBBS  GPIO_INPUT_MODE2_A, r1, GPIO0_8_GPIO_INPUT_0    ; si se detecta flanco asc
     375 000002a4 000000D109E104    QBBS  GPIO_INPUT_MODE2_A, r1, GPIO0_9_GPIO_INPUT_1    ;
     376 000002a8 000000D10AE103    QBBS  GPIO_INPUT_MODE2_A, r1, GPIO0_10_GPIO_INPUT_2   ;
     377 000002ac 000000D10BE102    QBBS  GPIO_INPUT_MODE2_A, r1, GPIO0_11_GPIO_INPUT_3   ;
     378 000002b0 0000007F0000A1    QBA   level_gpio_output_mode0                         ;
     379 000002b4                 GPIO_INPUT_MODE2_A:
     380; clear IRQ_GPIO_IRQSTATUS_1
     381 000002b4 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     382 000002bc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     383 000002c0 0000001F08E1E1    SET   r1, r1, GPIO0_8_GPIO_INPUT_0                    ; borramos todas las interrupciones
     384 000002c4 0000001F09E1E1    SET   r1, r1, GPIO0_9_GPIO_INPUT_1                    ;
     385 000002c8 0000001F0AE1E1    SET   r1, r1, GPIO0_10_GPIO_INPUT_2                   ;
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    8

     386 000002cc 0000001F0BE1E1    SET   r1, r1, GPIO0_11_GPIO_INPUT_3                   ;
     387 000002d0 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     388; read GPIO IN
     389 000002d4 7138802444E0C0    LDI32 r0, (GPIO0|GPIO_DATAIN)                         ;
     390 000002dc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     391; write GPIO IN DATA INTO SHARED
     392 000002e0 0F0080240000C0    LDI32 r0, 0xF00                                       ; mascara desde bit8 a bit11 porque en el regi
     393 000002e8 00000010E0E1E1    AND   r1, r1, r0                                      ;
     394 000002ec 0000000B08E1E1    LSR   r1, r1, 8                                       ; se desplazan 8 posiciones para que los datos
     395; set flag rising detect
     396 000002f0 0000001F0CE1E1    SET   r1, r1, GPIO_INPUT_MODE2_DATARDY_FLAG           ; bit12-> flag rising detect
     397 000002f4 000000E10C3481    SBBO  &r1, r20, SHD_GPIO_INPUT_MODE2_DATA, 4          ; Cargamos valores de las entradas gpio_read b
     398 000002f8 0000007F00008F    QBA   level_gpio_output_mode0                         ;
     399
     400 000002fc                 GPIO_OUTPUT_MODE0:
     401; clr flag gpio_output
     402 000002fc 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     403 00000300 0000001D03E0E0    CLR   r0, r0, GPIO_OUTPUT_MODE0_FLAG                  ;
     404 00000304 000000E1003480    SBBO  &r0, r20, SHD_FLAGS, 4                          ;
     405; read GPIO_DATAOUT
     406 00000308 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     407 00000310 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     408; write GPIO DATAOUT INTO SHARED
     409 00000314 0000802403C0C0    LDI32 r0, 0x03C00000                                  ; mascara desde bit22 a bit25 porque en el reg
     410 0000031c 00000010E0E1E1    AND   r1, r1, r0                                      ;
     411 00000320 0000000B12E1E1    LSR   r1, r1, 18                                      ; se desplazan 18 posiciones para que los dato
     412; set flag data ready
     413 00000324 0000001F0CE1E1    SET   r1, r1, GPIO_OUTPUT_MODE0_DATARDY_FLAG          ; bit12-> flag gpio_output get complete
     414 00000328 000000E1103481    SBBO  &r1, r20, SHD_GPIO_OUTPUT_MODE0_DATA, 4         ; Cargamos valores de gpio_out 22-25 en los bi
     415 0000032c 0000007F000084    QBA   level_gpio_output_mode1                         ;
     416
     417 00000330                 GPIO_OUTPUT_MODE1:
     418;  CLR   r30, pruout_fs_sample_test
     419; clr flag gpio_write
     420 00000330 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     421 00000334 0000001D04E0E0    CLR   r0, r0, GPIO_OUTPUT_MODE1_FLAG                  ; bit4 flag gpio_output set
     422 00000338 000000E1003480    SBBO  &r0, r20, SHD_FLAGS, 4                          ;
     423; read gpio_output to set
     424 0000033c 000000F1143480    LBBO  &r0, r20, SHD_GPIO_OUTPUT_MODE1_DATA, 4         ;
     425 00000340 000000110FE0E1    AND   r1, r0, 0x0F                                    ; extrae los primeros 4 bits (0-3) en r1. Flag
     426 00000344 00000011F0E0E2    AND   r2, r0, 0xF0                                    ; extrae los bits 4-7 en r2. Pin state
     427 00000348 0000000B04E2E2    LSR   r2, r2, 4                                       ; desplaza los bits 4-7 a la posicion menos si
     428 0000034c 000083240000C3    LDI32 r3, 0                                           ; inicializa el contador de bits (0 a 3)
     429 00000354 000084240040C4    LDI32 r4, GPIO_OUT_BASE                               ; direccion base GPIO_OUT_BASE
     430 0000035c                 check_bits_w:
     431 0000035c 0000001101E2E5    AND   r5, r2, 1                                       ; extrae el bit menos significativo de r2 (sta
     432 00000360 000000D0E3E109    QBBS  gpio_write_out_funct, r1, r3                    ; qbbs myLabel r1, r3. Branch if( r1&(1<<r3) )
     433 00000364                 GPIO_OUTPUT_MODE1_A:
     434 00000364 0000000B01E2E2    LSR   r2, r2, 1                                       ; desplaza r2 a la derecha para procesar el si
     435 00000368 0000000901E4E4    LSL   r4, r4, 1                                       ; desplaza hacia el proximo bit de GPIO_out1,.
     436 0000036c 0000000101E3E3    ADD   r3, r3, 1                                       ; count++
     437 00000370 0000006704E3FB    QBGT  check_bits_w, r3, 4                             ; cuatro salidas. qbgt myLabel, r3, r4. Branch
     438; set flag data complete
     439 00000374 0000002EFF8180    ZERO  &r0, 4                                          ; shared erase
     440 00000378 0000001F0CE0E0    SET   r0, r0, GPIO_OUTPUT_MODE1_DATARDY_FLAG          ; shared bit12-> flag write complete
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE    9

     441 0000037c 000000E1143480    SBBO  &r0, r20, SHD_GPIO_OUTPUT_MODE1_DATA, 4         ;
     442 00000380 0000007F000071    QBA   level_motor_mode0                               ;
     443
     444 00000384                 gpio_write_out_funct:
     445 00000384 000000D100E502    QBBS  write_out_set, r5, 0                            ; jamp si bit0 de r5 es set
     446 00000388 000000C900E505    QBBC  write_out_clr, r5, 0                            ; jamp si bit0 de r5 es clr
     447 0000038c                 write_out_set:
     448 0000038c C1948624481AC6    LDI32 r6, (GPIO2|GPIO_SETDATAOUT)                     ; load addr for GPIO Set data r6
     449 00000394 000000E1002684    SBBO  &r4, r6, 0, 4                                   ; write r4 to the r6 address valu
     450 00000398 0000007F0000F3    QBA   GPIO_OUTPUT_MODE1_A                             ;
     451 0000039c                 write_out_clr:
     452 0000039c C1908624481AC6    LDI32 r6, (GPIO2|GPIO_CLRDATAOUT)                     ; load addr for GPIO Clear data.
     453 000003a4 000000E1002684    SBBO  &r4, r6, 0, 4                                   ; write r4 to the r6 address
     454 000003a8 0000007F0000EF    QBA   GPIO_OUTPUT_MODE1_A                             ;
     455
     456 000003ac                 MOTOR_MODE0:
     457; clr flag motor config get
     458 000003ac 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ;
     459 000003b0 0000001D05E0E0    CLR   r0,r0, MOTOR_MODE0_FLAG                         ; bit5 flag get state
     460 000003b4 000000E1003480    SBBO  &r0, r20, SHD_FLAGS, 4                          ;
     461; read MOTOR
     462 000003b8 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for DATAOUT
     463 000003c0 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     464; write GPIO IN DATA INTO SHARED
     465 000003c4 3FC080240000C0    LDI32 r0, 0x03FC0                                     ; mascara desde bit6-13 para sacar enable-dir 
     466 000003cc 00000010E0E1E1    AND   r1, r1, r0                                      ;
     467 000003d0 0000000B02E1E1    LSR   r1, r1, 2                                       ; se desplazan 2 posiciones para que los datos
     468; set flag data ready
     469 000003d4 0000001F0CE1E1    SET   r1, r1, MOTOR_MODE0_DATARDY_FLAG                ; bit12-> flag get
     470 000003d8 000000E1183481    SBBO  &r1, r20, SHD_MOTOR_MODE0_DATA, 4               ; Cargamos valores enable-dir de todos los mot
     471 000003dc 0000007F00005C    QBA   level_motor_mode1                               ;
     472
     473 000003e0                 MOTOR_MODE1:
     474;  CLR   r30, pruout_fs_sample_test                     ; debug-> verificamos que estamos entrando a l
     475; no clr flag shared[0]para que quede continuamente leyendo
     476; get irq status
     477 000003e0 C0308024481AC0    LDI32 r0, (GPIO2|GPIO_IRQSTATUS_1)                    ;
     478 000003e8 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     479 000003ec 000000D103E102    QBBS  MOTOR_MODE1_A, r1, GPIO2_3_INPUT_MOTOR_TRIGGER  ; si se detecta flanco asc enviamos los estado
     480 000003f0 0000007F000059    QBA   level_motor_mode2                               ;
     481 000003f4                 MOTOR_MODE1_A:
     482;  CLR   r30, pruout_fs_sample_test
     483; clear IRQ_GPIO_IRQSTATUS_1
     484 000003f4 C0308024481AC0    LDI32 r0, (GPIO2|GPIO_IRQSTATUS_1)                    ;
     485 000003fc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     486 00000400 0000001F03E1E1    SET   r1, r1, GPIO2_3_INPUT_MOTOR_TRIGGER             ;
     487 00000404 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     488; read MOTOR
     489 00000408 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     490 00000410 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     491; write GPIO IN DATA INTO SHARED
     492 00000414 3FC080240000C0    LDI32 r0, 0x03FC0                                     ; mascara desde bit6-13 para sacar enable-dir 
     493 0000041c 00000010E0E1E1    AND   r1, r1, r0                                      ;
     494 00000420 0000000B02E1E1    LSR   r1, r1, 2                                       ; se desplazan 2 posiciones para que los datos
     495; set flag data ready
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE   10

     496 00000424 0000001F0CE1E1    SET   r1, r1, MOTOR_MODE1_DATARDY_FLAG                ; shared bit12-> flag motor_config get
     497 00000428 000000E11C3481    SBBO  &r1, r20, SHD_MOTOR_MODE1_DATA, 4               ; Cargamos valores enable-dir de todos los mot
     498 0000042c 0000007F00004A    QBA   level_motor_mode2                               ;
     499
     500 00000430                 MOTOR_MODE2:
     501; no clr flag shared[0]para que quede continuamente leyendo
     502; get irq status
     503 00000430 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ;
     504 00000438 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     505 0000043c 000000D116E105    QBBS  MOTOR_MODE2_A, r1, GPIO0_22_INPUT_MA_DISABLE    ; si se detecta flanco asc enviamos los estado
     506 00000440 000000D117E104    QBBS  MOTOR_MODE2_A, r1, GPIO0_23_INPUT_MA_TOGGLE_DIR ;
     507 00000444 000000D11AE103    QBBS  MOTOR_MODE2_A, r1, GPIO0_26_INPUT_MB_DISABLE    ;
     508 00000448 000000D11BE102    QBBS  MOTOR_MODE2_A, r1, GPIO0_27_INPUT_MB_TOGGLE_DIR ;
     509 0000044c 0000007F000044    QBA   level_motor_mode3                               ;
     510 00000450                 MOTOR_MODE2_A:
     511; no borramos las interrupciones lo hacemos despues de evaluar todas las funciones al final del main l
     512; read MOTOR
     513 00000450 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ;
     514 00000458 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     515; write GPIO IN DATA INTO SHARED
     516 0000045c 3FC080240000C0    LDI32 r0, 0x03FC0                                     ; mascara desde bit6-13 para sacar enable-dir 
     517 00000464 00000010E0E1E1    AND   r1, r1, r0                                      ;
     518 00000468 0000000B02E1E1    LSR   r1, r1, 2                                       ; se desplazan 2 posiciones para que los datos
     519; set flag data ready
     520 0000046c 0000001F0CE1E1    SET   r1, r1, MOTOR_MODE2_DATARDY_FLAG                ; shared bit12-> flag motor_config get
     521 00000470 000000E1203481    SBBO  &r1, r20, SHD_MOTOR_MODE2_DATA, 4               ; Cargamos valores enable-dir de todos los mot
     522 00000474 0000007F00003A    QBA   level_motor_mode3                               ;
     523
     524 00000478                 MOTOR_MODE3:
     525; Cargamos los step
     526 00000478 000000F128348A    LBBO  &r10, r20, SHD_MOTOR_STEP_PERIOD_A, 4           ; read shared STEP_PERIOD_A
     527 0000047c 000000F12C348B    LBBO  &r11, r20, SHD_MOTOR_STEP_PERIOD_B, 4           ; read shared STEP_PERIOD_B
     528 00000480 000000F130348C    LBBO  &r12, r20, SHD_MOTOR_STEP_PERIOD_C, 4           ; read shared STEP_PERIOD_C
     529 00000484 000000F134348D    LBBO  &r13, r20, SHD_MOTOR_STEP_PERIOD_D, 4           ; read shared STEP_PERIOD_C
     530; clr flag motor set
     531 00000488 000000F1003480    LBBO  &r0, r20, SHD_FLAGS, 4                          ; Shared
     532 0000048c 0000001D08E0E0    CLR   r0,r0, MOTOR_MODE3_FLAG                         ; bit5 flag motor
     533 00000490 000000E1003480    SBBO  &r0, r20, SHD_FLAGS, 4                          ;
     534; load data
     535 00000494 000000F1243480    LBBO  &r0, r20, SHD_MOTOR_MODE3_DATA, 4               ;
     536 00000498 000000110FE0E1    AND   r1, r0, 0x0F                                    ; extrae los priomeros 4 bits (0-3) en r1. Fla
     537 0000049c 0FF082240000C2    LDI32 r2, 0xFF0                                       ; mascara bit 4-11
     538 000004a4 00000010E2E0E2    AND   r2, r0, r2                                      ; extrae los bits 4-11 en r2. Pins enable-dir
     539 000004a8 0000000B04E2E2    LSR   r2, r2, 4                                       ; desplaza los bits 4-11 a la posicion menos s
     540 000004ac 000083240000C3    LDI32 r3, 0                                           ; inicializa el contador de bits (0 a 3)
     541 000004b4 004084240000C4    LDI32 r4, GPIO_MOTOR_ENA_BASE                         ; direccion base gpio MOTOR_ENA_Base
     542 000004bc 008085240000C5    LDI32 r5, GPIO_MOTOR_DIR_BASE                         ; direccion base gpio MOTOR_DIR_Base
     543 000004c4                 check_bits_m:
     544 000004c4 0000001103E2E6    AND   r6, r2, 0x03                                    ; extrae los dos primeros  bits. Bit0 -> Enabl
     545 000004c8 000000D0E3E10A    QBBS  motor_config, r1, r3                            ; qbbs myLabel r2, r4. Branch if( r2&(1<<r4) )
     546 000004cc                 MOTOR_MODE3_A1:
     547 000004cc 0000000B02E2E2    LSR   r2, r2, 2                                       ; desplaza r2 a la derecha para procesar los s
     548 000004d0 0000000902E4E4    LSL   r4, r4, 2                                       ; desplaza a la siguiente Ena
     549 000004d4 0000000902E5E5    LSL   r5, r5, 2                                       ; desplaza a la siguente Dir
     550 000004d8 0000000101E3E3    ADD   r3, r3, 1                                       ; count++
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE   11

     551 000004dc 0000006704E3FA    QBGT  check_bits_m, r3, 4                             ; cuatro salidas. qbgt myLabel, r3, r4. Branch
     552; set flag motor config complete
     553 000004e0 0000002EFF8180    ZERO  &r0, 4                                          ; shared erase
     554 000004e4 0000001F0CE0E0    SET   r0, r0, MOTOR_MODE3_DATARDY_FLAG                ; shared bit12-> flag motor config complete
     555 000004e8 000000E1243480    SBBO  &r0, r20, SHD_MOTOR_MODE3_DATA, 4               ;
     556 000004ec 0000007F00001E    QBA   level_motorA_step_time                          ;
     557
     558 000004f0                 motor_config:
     559 000004f0 000000D100E604    QBBS  enable_set, r6, 0                               ;
     560 000004f4 000000C900E607    QBBC  enable_clr, r6, 0                               ;
     561 000004f8                 MOTOR_MODE3_A2:
     562 000004f8 000000D101E60A    QBBS  dir_set, r6, 1                                  ;
     563 000004fc 000000C901E60D    QBBC  dir_clr, r6, 1                                  ;
     564 00000500                 enable_set:
     565 00000500 C1948724481AC7    LDI32 r7, (GPIO2|GPIO_SETDATAOUT)                     ; load addr for GPIO Set data r7
     566 00000508 000000E1002784    SBBO  &r4, r7, 0, 4                                   ; write r4 to the r7 address value
     567 0000050c 0000007F0000FB    QBA   MOTOR_MODE3_A2                                  ;
     568 00000510                 enable_clr:
     569 00000510 C1908724481AC7    LDI32 r7, (GPIO2|GPIO_CLRDATAOUT)                     ; load addr for GPIO Set data r7
     570 00000518 000000E1002784    SBBO  &r4, r7, 0, 4                                   ; write r4 to the r6 address value
     571 0000051c 0000007F0000F7    QBA   MOTOR_MODE3_A2                                  ;
     572 00000520                 dir_set:
     573 00000520 C1948724481AC7    LDI32 r7, (GPIO2|GPIO_SETDATAOUT)                     ; load addr for GPIO Set data r7
     574 00000528 000000E1002785    SBBO  &r5, r7, 0, 4                                   ; write r5 to the r7 address value
     575 0000052c 0000007F0000E8    QBA   MOTOR_MODE3_A1                                  ;
     576 00000530                 dir_clr:
     577 00000530 C1908724481AC7    LDI32 r7, (GPIO2|GPIO_CLRDATAOUT)                     ; load addr for GPIO Set data r7
     578 00000538 000000E1002785    SBBO  &r5, r7, 0, 4                                   ; write r5 to the r7 address value
     579 0000053c 0000007F0000E4    QBA   MOTOR_MODE3_A1                                  ;
     580
     581 00000540                 STEP_PERIOD_A:
     582 00000540 0000000501EAEA    SUB   r10, r10, 1                                     ; se resta 1 a r10. r10 fue cargado cuando se 
     583 00000544 0000005100EA02    QBEQ  TOGGLE_PIN_A, r10, 0                            ; toggle pin step cuando la cuenta llega a 0
     584 00000548 0000007F00000C    QBA   level_motorB_step_time                          ; sino volvemos al loop principal
     585 0000054c                 TOGGLE_PIN_A:
     586 0000054c C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
     587 00000554 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     588 00000558 400082240000C2    LDI32 r2, OUTPUT_MA_S                                 ; GPIO2_14_MA_S
     589 00000560 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle GPIO2_14_MA_S
     590 00000564 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos la salida GPIO2_14_MA_S
     591 00000568 000000F128348A    LBBO  &r10, r20, SHD_MOTOR_STEP_PERIOD_A, 4           ; cargamos nuevamente el valor de shared[4] pa
     592 0000056c 0000007F000003    QBA   level_motorB_step_time                          ; volvemos al loop principal
     593
     594 00000570                 DISABLE_OUTPUT_MA:
     595 00000570 C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ; recordar que hay que hacer un set para clr
     596 00000578 000081240000C1    LDI32 r1, 0x0                                         ; ponemos en estado bajo las salidas
     597 00000580 0000001F07E1E1    SET   r1, r1, OUTPUT_MA_D                             ;
     598 00000584 0000001F0EE1E1    SET   r1, r1, 14                                      ; OUTPUT_MA_S lo hacemos asi para no agregar m
     599 00000588 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     600 0000058c 0000007D0000FB    QBA   level_motorB_step_time                          ;
     601
     602 00000590                 STEP_PERIOD_B:
     603 00000590 0000000501EBEB    SUB   r11, r11, 1                                     ; se resta 1 a r11. r11 fue cargado cuando se 
     604 00000594 0000005100EB02    QBEQ  TOGGLE_PIN_B, r11, 0                            ; toggle pin step cuando la cuenta llega a 0
     605 00000598 0000007D0000FD    QBA   level_motorC_step_time                          ; sino volvemos al loop principal
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE   12

     606 0000059c                 TOGGLE_PIN_B:
     607 0000059c C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
     608 000005a4 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     609 000005a8 800082240000C2    LDI32 r2, OUTPUT_MB_S                                 ; GPIO2_15_MB_S
     610 000005b0 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle GPIO2_15_MB_S
     611 000005b4 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos la salida GPIO2_15_MB_S
     612 000005b8 000000F12C348B    LBBO  &r11, r20, SHD_MOTOR_STEP_PERIOD_B, 4           ; cargamos nuevamente el valor de shared[5] pa
     613 000005bc 0000007D0000F4    QBA   level_motorC_step_time                          ; volvemos al loop principal
     614
     615 000005c0                 DISABLE_OUTPUT_MB:
     616 000005c0 C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ; recordar que hay que hacer un set para clr
     617 000005c8 000081240000C1    LDI32 r1, 0x0                                         ; ponemos en estado bajo las salidas
     618 000005d0 0000001F09E1E1    SET   r1, r1, OUTPUT_MB_D                             ;
     619 000005d4 0000001F0FE1E1    SET   r1, r1, 15                                      ; OUTPUT_MB_S
     620 000005d8 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     621 000005dc 0000007D0000EC    QBA   level_motorC_step_time                          ;
     622
     623 000005e0                 STEP_PERIOD_C:
     624 000005e0 0000000501ECEC    SUB   r12, r12, 1                                     ; se resta 1 a r12. r12 fue cargado cuando se 
     625 000005e4 0000005100EC02    QBEQ  TOGGLE_PIN_C, r12, 0                            ; toggle pin step cuando la cuenta llega a 0
     626 000005e8 0000007D0000EE    QBA   level_motorD_step_time                          ; sino volvemos al loop principal
     627 000005ec                 TOGGLE_PIN_C:
     628 000005ec C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
     629 000005f4 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     630 000005f8 000082240001C2    LDI32 r2, OUTPUT_MC_S                                 ; GPIO2_16_MC_S
     631 00000600 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle GPIO2_16_MC_S
     632 00000604 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos la salida GPIO2_16_MC_S
     633 00000608 000000F130348C    LBBO  &r12, r20, SHD_MOTOR_STEP_PERIOD_C, 4           ; cargamos nuevamente el valor de shared[6] pa
     634 0000060c 0000007D0000E5    QBA   level_motorD_step_time                          ; volvemos al loop principal
     635
     636 00000610                 DISABLE_OUTPUT_MC:
     637 00000610 C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ; recordar que hay que hacer un set para clr
     638 00000618 000081240000C1    LDI32 r1, 0x0                                         ; ponemos en estado bajo las salidas
     639 00000620 0000001F0BE1E1    SET   r1, r1, OUTPUT_MC_D                             ;
     640 00000624 0000001F10E1E1    SET   r1, r1, 16                                      ; OUTPUT_MC_S
     641 00000628 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     642 0000062c 0000007D0000DD    QBA   level_motorD_step_time                          ;
     643
     644 00000630                 STEP_PERIOD_D:
     645 00000630 0000000501EDED    SUB   r13, r13, 1                                     ; se resta 1 a r13. r13 fue cargado cuando se 
     646 00000634 0000005100ED02    QBEQ  TOGGLE_PIN_D, r13, 0                            ; toggle pin step cuando la cuenta llega a 0
     647 00000638 0000007D0000DF    QBA   level_motorA_disable                            ; sino volvemos al loop principal
     648 0000063c                 TOGGLE_PIN_D:
     649 0000063c C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
     650 00000644 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     651 00000648 000082240002C2    LDI32 r2, OUTPUT_MD_S                                 ; GPIO2_17_MD_S
     652 00000650 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle GPIO2_17_MD_S
     653 00000654 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos la salida GPIO2_17_MD_S
     654 00000658 000000F134348D    LBBO  &r13, r20, SHD_MOTOR_STEP_PERIOD_D, 4           ; cargamos nuevamente el valor de shared[7] pa
     655 0000065c 0000007D0000D6    QBA   level_motorA_disable                            ; volvemos al loop principal
     656
     657 00000660                 DISABLE_OUTPUT_MD:
     658 00000660 C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ; recordar que hay que hacer un set para clr
     659 00000668 000081240000C1    LDI32 r1, 0x0                                         ; ponemos en estado bajo las salidas
     660 00000670 0000001F0DE1E1    SET   r1, r1, OUTPUT_MD_D                             ;
PRU Assembler Unix v2.3.3 Sat Apr  5 20:42:01 2025

Tools Copyright (c) 2012-2018 Texas Instruments Incorporated
src/pru1-digital.asm                                                 PAGE   13

     661 00000674 0000001F11E1E1    SET   r1, r1, 17                                      ; OUTPUT_MD_S
     662 00000678 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     663 0000067c 0000007D0000CE    QBA   level_motorA_disable                            ;
     664
     665 00000680                 DISABLE_MA:
     666 00000680 C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ;
     667 00000688 004081240000C1    LDI32 r1, GPIO_MOTOR_ENA_BASE                         ; direccion base gpio MOTOR_ENA_Base Motor_MA
     668 00000690 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     669 00000694 0000007D0000CC    QBA   level_motorA_toggle                             ;
     670
     671 00000698                 TOGGLE_DIR_MA:
     672; toggle drection pins
     673 00000698 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
     674 000006a0 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     675 000006a4 008082240000C2    LDI32 r2, GPIO_MOTOR_DIR_BASE                         ;
     676 000006ac 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle
     677 000006b0 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos dir
     678; clear IRQ_GPIO_IRQSTATUS_1
     679 000006b4 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ; load addr for GPIO2
     680 000006bc 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     681 000006c0 0000001F17E1E1    SET   r1, r1, GPIO0_23_INPUT_MA_TOGGLE_DIR            ;
     682 000006c4 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     683 000006c8 0000007D0000C3    QBA   level_motorB_disable                            ; volvemos al loop principal
     684
     685 000006cc                 DISABLE_MB:
     686 000006cc C1908024481AC0    LDI32 r0, (GPIO2|GPIO_CLRDATAOUT)                     ;
     687 000006d4 004081240000C1    LDI32 r1, GPIO_MOTOR_ENA_BASE                         ; direccion gpio MOTOR_ENA_Base Motor_MB
     688 000006dc 0000000902E1E1    LSL   r1, r1, 2                                       ; hay que moverse 2 posiciones Enable motor_MB
     689 000006e0 000000E1002081    SBBO  &r1, r0, 0, 4                                   ;
     690 000006e4 0000007D0000C0    QBA   level_motorB_toggle                             ;
     691
     692 000006e8                 TOGGLE_DIR_MB:
     693; toggle direction pins
     694 000006e8 C13C8024481AC0    LDI32 r0, (GPIO2|GPIO_DATAOUT)                        ; load addr for GPIO2
     695 000006f0 000000F1002081    LBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     696 000006f4 008082240000C2    LDI32 r2, GPIO_MOTOR_DIR_BASE                         ;
     697 000006fc 0000000902E2E2    LSL   r2, r2, 2                                       ;
     698 00000700 00000014E2E1E1    XOR   r1, r1, r2                                      ; toggle
     699 00000704 000000E1002081    SBBO  &r1, r0, 0 , 4                                  ; actualizamos la salida
     700; clear IRQ_GPIO_IRQSTATUS_1
     701 00000708 7030802444E0C0    LDI32 r0, (GPIO0|GPIO_IRQSTATUS_1)                    ; load addr for GPIO2
     702 00000710 000000F1002081    LBBO  &r1, r0, 0, 4                                   ;
     703 00000714 0000001F1BE1E1    SET   r1, r1, GPIO0_27_INPUT_MB_TOGGLE_DIR            ;
     704 00000718 000000E1002081    SBBO  &r1, r0, 0, 4                                   ; Load the values at r0 into r1.
     705 0000071c 0000007D000080    QBA   MAIN_LOOP                                       ; volvemos al loop principal
     706
     707 00000720 00239F240000DF    LDI32   R31, (PRU0_R31_VEC_VALID|PRU_EVTOUT_0)        ;
     708 00000728 0000002A000000    HALT                                                  ; halt the pru program

No Assembly Errors, No Assembly Warnings
